--- FILE: ./run_test.sh ---
#!/bin/bash

# =================================================================
#  Automated Test Script for Family Budget App
# =================================================================
#  This script will:
#  1. Completely reset the application and database.
#  2. Restart the application.
#  3. Set up all necessary test data for June.
#  4. Run the final dashboard test.
# =================================================================

# --- Configuration ---
BASE_URL="http://money.local"
USER_EMAIL="stuart_hobbs@icloud.com"
USER_PASSWORD="Georgia"
# Make sure this file exists in your home directory on the Pi
CSV_FILE_PATH="/home/stuart/activity.csv"


# --- Helper Functions ---
function echo_step {
  echo "-----------------------------------------------------"
  echo "STEP: $1"
  echo "-----------------------------------------------------"
}

# --- Main Script ---

# 1. Reset the Environment
echo_step "Stopping application and clearing all data..."
cd ~/family-budget-app || exit
docker compose down -v
echo "Environment cleared."
echo

# 2. Restart the Application
echo_step "Restarting application in the background..."
docker compose up -d
echo "Waiting for services to start..."
sleep 15 # Wait 15 seconds for the server to be ready
echo "Services should be running."
echo

# 3. Set Up Test Data
echo_step "Setting up test data..."

# 3a. Register User
echo "Registering user: $USER_EMAIL"
curl -s -X POST -H "Content-Type: application/json" -d "{\"email\":\"$USER_EMAIL\", \"password\":\"$USER_PASSWORD\"}" $BASE_URL/api/auth/register
echo

# 3b. Login and Capture Token
echo "Logging in to get auth token..."
LOGIN_RESPONSE=$(curl -s -X POST -H "Content-Type: application/json" -d "{\"email\":\"$USER_EMAIL\", \"password\":\"$USER_PASSWORD\"}" $BASE_URL/api/auth/login)
TOKEN=$(echo $LOGIN_RESPONSE | jq -r '.token')

if [ "$TOKEN" == "null" ] || [ -z "$TOKEN" ]; then
  echo "ERROR: Failed to get login token. Exiting."
  exit 1
fi
echo "Login successful. Token captured."
echo

# 3c. Upload Transactions
echo "Uploading transactions from $CSV_FILE_PATH..."
curl -s -X POST -H "Authorization: Bearer $TOKEN" -F "transactionsFile=@$CSV_FILE_PATH" $BASE_URL/api/transactions/upload
echo
echo

# 3d. Create Categories
echo "Creating 'Groceries' category and 'Supermarket' subcategory..."
curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $TOKEN" -d '{"name":"Groceries"}' $BASE_URL/api/categories > /dev/null
curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $TOKEN" -d '{"name":"Supermarket"}' $BASE_URL/api/categories/1/subcategories > /dev/null
echo "Categories created."
echo

# 3e. Categorize a June Transaction
echo "Finding a transaction from June to categorize..."
# Get the ID of the first uncategorized transaction
TX_ID=$(curl -s -H "Authorization: Bearer $TOKEN" $BASE_URL/api/transactions/uncategorized | jq '.[0].id')

if [ "$TX_ID" == "null" ] || [ -z "$TX_ID" ]; then
  echo "WARNING: Could not find an uncategorized transaction to categorize."
else
  echo "Found transaction with ID: $TX_ID. Categorizing it..."
  curl -s -X PUT -H "Content-Type: application/json" -H "Authorization: Bearer $TOKEN" -d '{"subcategory_id":1}' $BASE_URL/api/transactions/$TX_ID/categorize
  echo "Transaction categorized."
fi
echo

# 3f. Set Budget for June
echo "Setting budget for June..."
curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $TOKEN" -d '{"subcategory_id":1, "year":2025, "month":6, "amount":500}' $BASE_URL/api/budgets > /dev/null
echo "Budget set."
echo

# 4. Run Final Test
echo_step "Running final dashboard test..."
curl -H "Authorization: Bearer $TOKEN" $BASE_URL/api/dashboard/monthly-summary
echo
echo
echo "-----------------------------------------------------"
echo "TEST COMPLETE."
echo "-----------------------------------------------------"

--- FILE: ./create_state_file.sh ---
#!/bin/bash

# This script gathers specific project code and config files into a single text file.

OUTPUT_FILE="project_state.txt"

# Delete the old output file if it exists
rm -f $OUTPUT_FILE

echo "Gathering project code and config files into $OUTPUT_FILE..."

# Define a list of file patterns to find
find . \
-type f \( \
    -name "*.js" -o \
    -name "*.jsx" -o \
    -name "*.json" -o \
    -name "*.yml" -o \
    -name "*.sh" -o \
    -name "*.css" -o \
    -name "*.html" -o \
    -name "Dockerfile*" -o \
    -name "*.conf" \
\) \
-not -path '*/node_modules/*' \
-not -path '*/build/*' \
-not -path '*/.git/*' \
-not -name "$OUTPUT_FILE" \
-not -name ".DS_Store" | while read -r file; do
  # Print a header for each file
  echo "--- FILE: $file ---" >> $OUTPUT_FILE
  # Append the content of the file
  cat "$file" >> $OUTPUT_FILE
  # Add a newline for separation
  echo "" >> $OUTPUT_FILE
done

echo "Done. Please upload the file named '$OUTPUT_FILE'."

--- FILE: ./server/middleware/isAuthenticated.js ---
// =================================================================
//  Authentication Middleware (isAuthenticated.js)
// =================================================================
//  This middleware verifies the JWT token from the Authorization header.
// =================================================================

const jwt = require('jsonwebtoken');

// This MUST be the same secret key used in authController.js
const JWT_SECRET = 'your-super-secret-key-that-is-long-and-random';

function isAuthenticated(req, res, next) {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Access denied. No token provided.' });
  }

  const token = authHeader.split(' ')[1];

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded; // Add user payload to the request object
    next(); // Proceed to the next middleware or route handler
  } catch (error) {
    res.status(400).json({ message: 'Invalid token.' });
  }
}

module.exports = isAuthenticated;

--- FILE: ./server/config/database.js ---
const sqlite3 = require('sqlite3');
const { open } = require('sqlite');
const path = require('path');

const DB_PATH = path.join(__dirname, '..', 'data', 'sqlite', 'budget.db');

let dbInstance = null; // Singleton instance

async function openDb() {
  if (dbInstance) {
    return dbInstance;
  }
  dbInstance = await open({
    filename: DB_PATH,
    driver: sqlite3.Database
  });
  return dbInstance;
}

// New function to close the DB connection
async function closeDb() {
    if (dbInstance) {
        await dbInstance.close();
        dbInstance = null;
        console.log('Database connection closed.');
    }
}


async function migrate(db) {
  const schema = `
    CREATE TABLE IF NOT EXISTS users ( id INTEGER PRIMARY KEY AUTOINCREMENT, email TEXT NOT NULL UNIQUE, password_hash TEXT NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP );
    CREATE TABLE IF NOT EXISTS savings_accounts ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, institution TEXT, account_number TEXT, current_balance REAL NOT NULL DEFAULT 0, created_at DATETIME DEFAULT CURRENT_TIMESTAMP );
    CREATE TABLE IF NOT EXISTS categories ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL UNIQUE, linked_savings_account_id INTEGER, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (linked_savings_account_id) REFERENCES savings_accounts (id) ON DELETE SET NULL );
    CREATE TABLE IF NOT EXISTS subcategories ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, category_id INTEGER NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (category_id) REFERENCES categories (id) ON DELETE CASCADE, UNIQUE(name, category_id) );
    CREATE TABLE IF NOT EXISTS vendors ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL UNIQUE, display_name TEXT NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP );
    CREATE TABLE IF NOT EXISTS transactions ( 
        id INTEGER PRIMARY KEY AUTOINCREMENT, 
        transaction_date DATE NOT NULL, 
        description_original TEXT NOT NULL, 
        amount REAL NOT NULL, 
        is_debit BOOLEAN NOT NULL, 
        vendor_id INTEGER, 
        subcategory_id INTEGER, 
        is_split BOOLEAN DEFAULT 0, 
        notes TEXT, 
        source_account TEXT, 
        transaction_type TEXT NOT NULL DEFAULT 'expense',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
        FOREIGN KEY (vendor_id) REFERENCES vendors (id) ON DELETE SET NULL, 
        FOREIGN KEY (subcategory_id) REFERENCES subcategories (id) ON DELETE SET NULL 
    );
    CREATE TABLE IF NOT EXISTS split_transactions ( id INTEGER PRIMARY KEY AUTOINCREMENT, transaction_id INTEGER NOT NULL, subcategory_id INTEGER NOT NULL, amount REAL NOT NULL, notes TEXT, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (transaction_id) REFERENCES transactions (id) ON DELETE CASCADE, FOREIGN KEY (subcategory_id) REFERENCES subcategories (id) ON DELETE CASCADE );
    CREATE TABLE IF NOT EXISTS recurring_bills ( id INTEGER PRIMARY KEY AUTOINCREMENT, vendor_id INTEGER NOT NULL, subcategory_id INTEGER NOT NULL, amount REAL NOT NULL, day_of_month INTEGER NOT NULL, is_active BOOLEAN DEFAULT 1, start_date DATE NOT NULL, end_date DATE, notes TEXT, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (vendor_id) REFERENCES vendors (id), FOREIGN KEY (subcategory_id) REFERENCES subcategories (id) );
    CREATE TABLE IF NOT EXISTS budgets ( id INTEGER PRIMARY KEY AUTOINCREMENT, subcategory_id INTEGER NOT NULL, month INTEGER NOT NULL, year INTEGER NOT NULL, amount REAL NOT NULL, budget_type TEXT CHECK(budget_type IN ('allowance', 'rolling')) NOT NULL DEFAULT 'allowance', created_at DATETIME DEFAULT CURRENT_TIMESTAMP, UNIQUE(subcategory_id, month, year), FOREIGN KEY (subcategory_id) REFERENCES subcategories (id) ON DELETE CASCADE );
    CREATE TABLE IF NOT EXISTS app_settings ( id INTEGER PRIMARY KEY CHECK (id = 1), fiscal_day_start INTEGER NOT NULL, jurisdiction TEXT NOT NULL, setup_complete BOOLEAN DEFAULT 0 );
    CREATE TABLE IF NOT EXISTS public_holidays ( id INTEGER PRIMARY KEY AUTOINCREMENT, holiday_date DATE NOT NULL UNIQUE, name TEXT NOT NULL );
    CREATE TABLE IF NOT EXISTS savings_goals ( id INTEGER PRIMARY KEY AUTOINCREMENT, account_id INTEGER NOT NULL, title TEXT NOT NULL, target_amount REAL NOT NULL, current_amount REAL NOT NULL DEFAULT 0, target_date DATE, priority TEXT CHECK(priority IN ('high', 'medium', 'low')) NOT NULL DEFAULT 'medium', created_at DATETIME DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (account_id) REFERENCES savings_accounts (id) ON DELETE CASCADE );
    CREATE TABLE IF NOT EXISTS ignored_transactions ( id INTEGER PRIMARY KEY AUTOINCREMENT, transaction_date DATE NOT NULL, description_original TEXT NOT NULL, amount REAL NOT NULL, is_debit BOOLEAN NOT NULL, source_account TEXT, reason TEXT, created_at DATETIME DEFAULT CURRENT_TIMESTAMP );
    CREATE TABLE IF NOT EXISTS planned_income ( id INTEGER PRIMARY KEY AUTOINCREMENT, source_name TEXT NOT NULL, amount REAL NOT NULL, day_of_month INTEGER NOT NULL, is_active BOOLEAN DEFAULT 1, created_at DATETIME DEFAULT CURRENT_TIMESTAMP );
    CREATE TABLE IF NOT EXISTS categorization_rules ( id INTEGER PRIMARY KEY AUTOINCREMENT, vendor_id INTEGER NOT NULL UNIQUE, subcategory_id INTEGER NOT NULL, FOREIGN KEY (vendor_id) REFERENCES vendors(id) ON DELETE CASCADE, FOREIGN KEY (subcategory_id) REFERENCES subcategories(id) ON DELETE CASCADE );
    CREATE TABLE IF NOT EXISTS monthly_history ( id INTEGER PRIMARY KEY AUTOINCREMENT, year INTEGER NOT NULL, month INTEGER NOT NULL, subcategory_id INTEGER NOT NULL, budgeted_amount REAL NOT NULL, actual_spend REAL NOT NULL, budget_type TEXT NOT NULL, final_surplus_or_rollover REAL NOT NULL, reconciled_at DATETIME DEFAULT CURRENT_TIMESTAMP, is_closed BOOLEAN DEFAULT 1, UNIQUE(year, month, subcategory_id), FOREIGN KEY (subcategory_id) REFERENCES subcategories(id) ON DELETE CASCADE );
    CREATE TABLE IF NOT EXISTS import_profiles ( id INTEGER PRIMARY KEY AUTOINCREMENT, profile_name TEXT NOT NULL UNIQUE, date_col TEXT NOT NULL, description_col TEXT NOT NULL, amount_col TEXT, debit_col TEXT, credit_col TEXT, date_format TEXT );
  `;
  await db.exec(schema);
}
module.exports = { openDb, migrate, closeDb }; // Export the new function
--- FILE: ./server/server.js ---
const express = require('express');
const cors = require('cors');
const db = require('./config/database');

const app = express();
const PORT = process.env.PORT || 8080;

app.use(cors());
app.use(express.json());

// --- API Routes ---
const authRoutes = require('./routes/auth');
const categoryRoutes = require('./routes/categories');
const vendorRoutes = require('./routes/vendors');
const transactionRoutes = require('./routes/transactions');
const budgetRoutes = require('./routes/budgets');
const dashboardRoutes = require('./routes/dashboard');
const recurringBillRoutes = require('./routes/recurringBills');
const forecastRoutes = require('./routes/forecast');
const subcategoryRoutes = require('./routes/subcategories');
const settingsRoutes = require('./routes/settings');
const savingsGoalsRoutes = require('./routes/savingsGoals');
const plannedIncomeRoutes = require('./routes/plannedIncome');
const importProfileRoutes = require('./routes/importProfiles');
const backupRoutes = require('./routes/backup'); // <-- NEW

app.use('/api/auth', authRoutes);
app.use('/api/categories', categoryRoutes);
app.use('/api/vendors', vendorRoutes);
app.use('/api/transactions', transactionRoutes);
app.use('/api/budgets', budgetRoutes);
app.use('/api/dashboard', dashboardRoutes);
app.use('/api/recurring-bills', recurringBillRoutes);
app.use('/api/forecast', forecastRoutes);
app.use('/api/subcategories', subcategoryRoutes);
app.use('/api/settings', settingsRoutes);
app.use('/api/savings', savingsGoalsRoutes);
app.use('/api/planned-income', plannedIncomeRoutes);
app.use('/api/import-profiles', importProfileRoutes);
app.use('/api/backup', backupRoutes); // <-- NEW

app.get('/api/health', (req, res) => res.json({ status: 'ok' }));

async function startServer() {
  try {
    const database = await db.openDb();
    console.log('Database connection established.');
    await db.migrate(database);
    console.log('Database schema verified/migrated.');
    app.listen(PORT, () => console.log(`Server is listening on http://localhost:${PORT}`));
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
}

startServer();
--- FILE: ./server/models/SavingsAccount.js ---
const db = require('../config/database');

class SavingsAccount {
  static async create(accountData) {
    const { name, institution, account_number, current_balance } = accountData;
    const database = await db.openDb();
    const sql = `INSERT INTO savings_accounts (name, institution, account_number, current_balance) VALUES (?, ?, ?, ?)`;
    const result = await database.run(sql, [name, institution, account_number, current_balance || 0]);
    return { id: result.lastID, ...accountData };
  }

  static async findAll() {
    const database = await db.openDb();
    const accounts = await database.all('SELECT * FROM savings_accounts');
    const goals = await database.all('SELECT * FROM savings_goals');
    
    // Manually join in JavaScript to avoid potential SQL JSON issues in some environments
    return accounts.map(acc => ({
      ...acc,
      goals: goals.filter(g => g.account_id === acc.id)
    }));
  }

  static async findById(id) {
    const database = await db.openDb();
    const sql = `SELECT * FROM savings_accounts WHERE id = ?`;
    return await database.get(sql, [id]);
  }

  static async update(id, accountData) {
    const { name, institution, account_number, current_balance } = accountData;
    const database = await db.openDb();
    const sql = `UPDATE savings_accounts SET name = ?, institution = ?, account_number = ?, current_balance = ? WHERE id = ?`;
    await database.run(sql, [name, institution, account_number, current_balance, id]);
    return { id, ...accountData };
  }

  static async delete(id) {
    const database = await db.openDb();
    // This will cascade and delete related goals due to the database schema
    const sql = `DELETE FROM savings_accounts WHERE id = ?`;
    return await database.run(sql, [id]);
  }

  static async updateBalance(id, amount, dbInstance) {
    const database = dbInstance || await db.openDb();
    const sql = `UPDATE savings_accounts SET current_balance = current_balance + ? WHERE id = ?`;
    await database.run(sql, [amount, id]);
  }
}

module.exports = SavingsAccount;
--- FILE: ./server/models/SplitTransaction.js ---
const db = require('../config/database');

class SplitTransaction {
  static async bulkCreate(transactionId, splits, dbInstance) {
    if (!splits || splits.length === 0) return;
    const database = dbInstance || await db.openDb();
    const sql = `INSERT INTO split_transactions (transaction_id, subcategory_id, amount, notes) VALUES (?, ?, ?, ?)`;
    const stmt = await database.prepare(sql);
    try {
      for (const split of splits) {
        await stmt.run(transactionId, split.subcategory_id, split.amount, split.notes || null);
      }
    } finally {
      await stmt.finalize();
    }
  }

  static async deleteByTransactionId(transactionId, dbInstance) {
    const database = dbInstance || await db.openDb();
    const sql = 'DELETE FROM split_transactions WHERE transaction_id = ?';
    await database.run(sql, [transactionId]);
  }
}

module.exports = SplitTransaction;

--- FILE: ./server/models/Transaction.js ---
const db = require('../config/database');

class Transaction {
  static async exists(tx) {
    const database = await db.openDb();
    const sql = `SELECT 1 FROM transactions WHERE transaction_date = ? AND amount = ? AND is_debit = ? AND description_original = ? LIMIT 1`;
    const result = await database.get(sql, [tx.transaction_date, tx.amount, tx.is_debit, tx.description_original]);
    return !!result;
  }
  
  static async create(tx) {
    const database = await db.openDb();
    const type = tx.is_debit ? 'expense' : 'income'; // Set default type
    const sql = `INSERT INTO transactions (transaction_date, description_original, amount, is_debit, source_account, vendor_id, subcategory_id, transaction_type) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`;
    await database.run(sql, tx.transaction_date, tx.description_original, tx.amount, tx.is_debit, tx.source_account, tx.vendor_id, tx.subcategory_id, type);
  }


  static async bulkCreate(transactions) {
    if (transactions.length === 0) return;
    const database = await db.openDb();
    await database.exec('BEGIN TRANSACTION');
    try {
      const sql = `INSERT INTO transactions (transaction_date, description_original, amount, is_debit, source_account, vendor_id, subcategory_id, transaction_type) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`;
      const stmt = await database.prepare(sql);
      for (const tx of transactions) {
        const type = tx.is_debit ? 'expense' : 'income'; // Set default type
        await stmt.run(tx.transaction_date, tx.description_original, tx.amount, tx.is_debit, tx.source_account, tx.vendor_id, tx.subcategory_id, type);
      }
      await stmt.finalize();
      await database.exec('COMMIT');
    } catch (error) {
      await database.exec('ROLLBACK');
      console.error('Failed to bulk insert transactions:', error);
      throw error;
    }
  }

  static async findAll() {
    const database = await db.openDb();
    const sql = `
      SELECT t.*, s.name as subcategory_name, c.name as category_name, v.display_name as vendor_name
      FROM transactions t
      LEFT JOIN subcategories s ON t.subcategory_id = s.id
      LEFT JOIN categories c ON s.category_id = c.id
      LEFT JOIN vendors v ON t.vendor_id = v.id
      ORDER BY t.transaction_date DESC, t.id DESC
    `;
    return await database.all(sql);
  }

  static async findAllByDateRange(startDate, endDate) {
    const database = await db.openDb();
    const sql = `
      SELECT * FROM transactions
      WHERE transaction_date BETWEEN ? AND ?
      ORDER BY transaction_date ASC
    `;
    return await database.all(sql, [startDate, endDate]);
  }

  static async findById(id, dbInstance) {
    const database = dbInstance || await db.openDb();
    return await database.get('SELECT * FROM transactions WHERE id = ?', [id]);
  }

  static async findUncategorized() {
    const database = await db.openDb();
    return await database.all('SELECT * FROM transactions WHERE subcategory_id IS NULL AND is_split = 0 ORDER BY transaction_date DESC');
  }

  static async updateCategory(transactionId, subcategoryId) {
    const database = await db.openDb();
    // Setting a category should always mark it as not split
    await database.run('DELETE FROM split_transactions WHERE transaction_id = ?', [transactionId]);
    const result = await database.run('UPDATE transactions SET subcategory_id = ?, is_split = 0 WHERE id = ?', [subcategoryId, transactionId]);
    return result.changes;
  }
  
  static async updateType(transactionId, transactionType) {
    const database = await db.openDb();
    const result = await database.run('UPDATE transactions SET transaction_type = ? WHERE id = ?', [transactionType, transactionId]);
    return result.changes;
  }

  static async updateVendor(transactionId, vendorId, dbInstance) {
    const database = dbInstance || await db.openDb();
    const result = await database.run('UPDATE transactions SET vendor_id = ? WHERE id = ?', [vendorId, transactionId]);
    return result.changes;
  }

  static async markAsSplit(transactionId, dbInstance) {
    const sql = 'UPDATE transactions SET subcategory_id = NULL, is_split = 1 WHERE id = ?';
    const dbToUse = dbInstance || await db.openDb();
    await dbToUse.run(sql, [transactionId]);
  }
  
  static async getSummaryByDateRange(startDate, endDate) {
    const database = await db.openDb();
    const result = await database.get("SELECT SUM(CASE WHEN is_debit = 1 THEN amount ELSE 0 END) as total_spending, SUM(CASE WHEN is_debit = 0 AND transaction_type = 'income' THEN amount ELSE 0 END) as total_income FROM transactions WHERE transaction_date BETWEEN ? AND ?", [startDate, endDate]);
    return { total_spending: result.total_spending || 0, total_income: result.total_income || 0 };
  }
  
  static async getSpendingByCategory(startDate, endDate) {
    const database = await db.openDb();
    const sql = `
      SELECT
          c.id as category_id,
          c.name as category_name,
          SUM(s.amount) as actual_spending
      FROM (
          SELECT s.category_id, t.amount
          FROM transactions t
          JOIN subcategories s ON t.subcategory_id = s.id
          WHERE t.is_debit = 1 AND t.is_split = 0 AND t.transaction_date BETWEEN ? AND ?
          UNION ALL
          SELECT s.category_id, st.amount
          FROM split_transactions st
          JOIN transactions t_split ON st.transaction_id = t_split.id
          JOIN subcategories s ON st.subcategory_id = s.id
          WHERE t_split.is_debit = 1 AND t_split.transaction_date BETWEEN ? AND ?
      ) AS s
      JOIN categories c ON s.category_id = c.id
      GROUP BY c.id, c.name
      ORDER BY actual_spending DESC;
    `;
    return await database.all(sql, [startDate, endDate, startDate, endDate]);
  }
  
  static async getSpendingBySubCategory(startDate, endDate) {
    const database = await db.openDb();
     const sql = `
      SELECT
          s.id as subcategory_id,
          s.name as subcategory_name,
          c.id as category_id,
          c.name as category_name,
          COALESCE(SUM(spend.amount), 0) as actual_spending
      FROM subcategories s
      JOIN categories c ON s.category_id = c.id
      LEFT JOIN (
          SELECT t.subcategory_id, t.amount
          FROM transactions t
          WHERE t.is_debit = 1 AND t.transaction_date BETWEEN ? AND ? AND t.is_split = 0
          UNION ALL
          SELECT st.subcategory_id, st.amount
          FROM split_transactions st
          JOIN transactions t_split ON st.transaction_id = t_split.id
          WHERE t_split.is_debit = 1 AND t_split.transaction_date BETWEEN ? AND ?
      ) AS spend ON s.id = spend.subcategory_id
      GROUP BY s.id, s.name, c.id, c.name
      ORDER BY c.name, s.name;
    `;
    return await database.all(sql, [startDate, endDate, startDate, endDate]);
  }

  static async getTopVendorsByTransactionCount(startDate, endDate) {
    const database = await db.openDb();
    const sql = `
        SELECT v.display_name, COUNT(t.id) as transaction_count, SUM(t.amount) as total_spend
        FROM transactions t
        JOIN vendors v ON t.vendor_id = v.id
        WHERE t.is_debit = 1 AND t.transaction_date BETWEEN ? AND ?
        GROUP BY t.vendor_id
        ORDER BY transaction_count DESC
        LIMIT 5;
    `;
    return await database.all(sql, [startDate, endDate]);
  }

  static async getRecurringBillsTotalBySubCategory(endDate, startDate) {
      const database = await db.openDb();
      const sql = `
        SELECT s.id as subcategory_id, SUM(rb.amount) as total_recurring
        FROM recurring_bills rb
        JOIN subcategories s ON rb.subcategory_id = s.id
        WHERE 
          rb.is_active = 1 AND
          rb.start_date <= ? AND
          (rb.end_date IS NULL OR rb.end_date >= ?)
        GROUP BY s.id
      `;
      return await database.all(sql, [endDate, startDate]);
  }

  static async applyCategorizationRules() {
    const database = await db.openDb();
    const sql = `
      UPDATE transactions
      SET subcategory_id = (
        SELECT subcategory_id
        FROM categorization_rules
        WHERE vendor_id = transactions.vendor_id
      )
      WHERE
        subcategory_id IS NULL
        AND is_split = 0
        AND vendor_id IS NOT NULL
        AND vendor_id IN (SELECT vendor_id FROM categorization_rules)
    `;
    const result = await database.run(sql);
    return result.changes || 0;
  }
}

module.exports = Transaction;
--- FILE: ./server/models/Budget.js ---
const db = require('../config/database');

class Budget {
  static async bulkSet(budgets, dbInstance) {
    const database = dbInstance || await db.openDb();
    const useTransaction = !dbInstance; // Only manage transactions if we opened the DB connection

    if (useTransaction) await database.exec('BEGIN TRANSACTION');
    try {
      const sql = `
        INSERT INTO budgets (subcategory_id, year, month, amount, budget_type) 
        VALUES (?, ?, ?, ?, ?) 
        ON CONFLICT(subcategory_id, year, month) 
        DO UPDATE SET amount = excluded.amount, budget_type = excluded.budget_type;
      `;
      const stmt = await database.prepare(sql);
      for (const budget of budgets) {
        await stmt.run(budget.subcategory_id, budget.year, budget.month, parseFloat(budget.amount || 0), budget.budget_type || 'allowance');
      }
      await stmt.finalize();
      if (useTransaction) await database.exec('COMMIT');
    } catch (error) {
      if (useTransaction) await database.exec('ROLLBACK');
      throw error;
    }
  }

  static async getSingleBudget(subcategoryId, year, month, dbInstance) {
    const database = dbInstance || await db.openDb();
    const sql = `SELECT * FROM budgets WHERE subcategory_id = ? AND year = ? AND month = ?`;
    return await database.get(sql, [subcategoryId, year, month]);
  }

  static async getBudgetsByMonth(req, res) {
    const year = parseInt(req.params.year, 10);
    const month = parseInt(req.params.month, 10);
    try {
      const financialMonthService = await createFinancialMonthService();
      const { startDate, endDate } = financialMonthService.getFinancialMonthRange(year, month);

      const [budgets, spending, recurringBills] = await Promise.all([
        Budget.getBudgetsBySubCategoryForMonth(year, month),
        Transaction.getSpendingBySubCategory(startDate, endDate),
        Transaction.getRecurringBillsTotalBySubCategory(endDate, startDate)
      ]);

      const spendingMap = new Map(spending.map(item => [item.subcategory_id, item.actual_spending]));
      const recurringMap = new Map(recurringBills.map(item => [item.subcategory_id, item.total_recurring]));

      const dataWithCarryover = await Promise.all(budgets.map(async (budget) => {
        const carryover = budget.budget_type === 'rolling' ? await Budget.getPreviousMonthSurplus(budget.subcategory_id, year, month) : 0;
        return {
          ...budget,
          actual_spending: spendingMap.get(budget.subcategory_id) || 0,
          recurring_bills_total: recurringMap.get(budget.subcategory_id) || 0,
          carryover_amount: carryover,
        };
      }));

      res.status(200).json(dataWithCarryover);
    } catch (error) {
      console.error('Error fetching budgets:', error);
      res.status(500).json({ message: 'Server error fetching budgets.' });
    }
  }

  static async getBudgetTemplate(req, res) {
    try {
        const subcategories = await Subcategory.findAllWithParent();
        let csvString = "subcategory_id,category_name,subcategory_name";
        
        const today = new Date();
        const year = today.getFullYear();
        const month = today.getMonth();

        for (let i=0; i < 12; i++) {
            const d = new Date(year, month + i, 1);
            csvString += `,${d.toLocaleString('default', { month: 'short' })}-${d.getFullYear()}`;
        }
        csvString += "\n";

        for (const sc of subcategories) {
            csvString += `${sc.id},"${sc.category_name}","${sc.name}"` + ",0.00".repeat(12) + "\n";
        }

        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename="budget_template_forward_12m.csv"`);
        res.status(200).send(csvString);
    } catch (error) {
        res.status(500).json({ message: 'Server error generating budget template.' });
    }
  }

  static async uploadBudget(req, res) {
    if (!req.file) { return res.status(400).json({ message: 'No file uploaded.' }); }
    try {
        const records = parse(req.file.buffer, {
            columns: true,
            skip_empty_lines: true,
            trim: true,
        });

        const budgetsToSave = [];
        const today = new Date();

        for(const rec of records) {
            for(let i=0; i < 12; i++) {
                const d = new Date(today.getFullYear(), today.getMonth() + i, 1);
                const year = d.getFullYear();
                const month = d.getMonth() + 1;
                const monthShort = d.toLocaleString('default', { month: 'short' });
                const header = `${monthShort}-${year}`;
                
                if (rec[header]) {
                    budgetsToSave.push({
                        subcategory_id: parseInt(rec.subcategory_id, 10),
                        year: year,
                        month: month,
                        amount: parseFloat(rec[header] || 0),
                        budget_type: 'allowance' // Default, can be changed in UI
                    });
                }
            }
        }

        if (budgetsToSave.some(b => isNaN(b.subcategory_id) || isNaN(b.year) || isNaN(b.month) || isNaN(b.amount))) {
            return res.status(400).json({ message: 'CSV contains invalid or malformed data.' });
        }

        await Budget.bulkSet(budgetsToSave);
        res.status(200).json({ message: `Successfully uploaded and saved ${budgetsToSave.length} budget entries.` });
    } catch (error) {
        res.status(500).json({ message: `Error processing CSV file: ${error.message}` });
    }
  }
}

module.exports = BudgetController;
--- FILE: ./server/models/PublicHoliday.js ---
const db = require('../config/database');

class PublicHoliday {
  static async getAllAsSet() {
    const database = await db.openDb();
    const rows = await database.all('SELECT holiday_date FROM public_holidays');
    return new Set(rows.map(r => r.holiday_date));
  }
}

module.exports = PublicHoliday;

--- FILE: ./server/models/Subcategory.js ---
const db = require('../config/database');

class Subcategory {
  static async create(name, category_id) {
    const database = await db.openDb();
    const sql = `INSERT INTO subcategories (name, category_id) VALUES (?, ?)`;
    const result = await database.run(sql, [name, category_id]);
    return { id: result.lastID, name, category_id };
  }

  static async findAllWithParent() {
    const database = await db.openDb();
    const sql = `
      SELECT 
        s.id, 
        s.name, 
        c.name as category_name 
      FROM subcategories s
      JOIN categories c ON s.category_id = c.id
      ORDER BY c.name, s.name
    `;
    return await database.all(sql);
  }

  static async delete(id) {
    const database = await db.openDb();
    const sql = `DELETE FROM subcategories WHERE id = ?`;
    return await database.run(sql, [id]);
  }

  static async findParentCategory(subcategoryId) {
    const database = await db.openDb();
    const sql = `SELECT category_id FROM subcategories WHERE id = ?`;
    return await database.get(sql, [subcategoryId]);
  }
}

module.exports = Subcategory;
--- FILE: ./server/models/CategorizationRule.js ---
const db = require('../config/database');

class CategorizationRule {
  static async findRuleByVendor(vendorId) {
    const database = await db.openDb();
    const sql = 'SELECT * FROM categorization_rules WHERE vendor_id = ?';
    return await database.get(sql, [vendorId]);
  }

  static async createOrUpdateRule(vendorId, subcategoryId) {
    const database = await db.openDb();
    const sql = `
      INSERT INTO categorization_rules (vendor_id, subcategory_id)
      VALUES (?, ?)
      ON CONFLICT(vendor_id) DO UPDATE SET
        subcategory_id = excluded.subcategory_id;
    `;
    await database.run(sql, [vendorId, subcategoryId]);
  }
}

module.exports = CategorizationRule;

--- FILE: ./server/models/SavingsGoal.js ---
const db = require('../config/database');

class SavingsGoal {
  static async create(goalData) {
    const { account_id, title, target_amount, current_amount, target_date, priority } = goalData;
    const database = await db.openDb();
    const sql = `INSERT INTO savings_goals (account_id, title, target_amount, current_amount, target_date, priority) VALUES (?, ?, ?, ?, ?, ?)`;
    const result = await database.run(sql, [account_id, title, target_amount, current_amount || 0, target_date, priority]);
    return { id: result.lastID, ...goalData };
  }

  static async update(id, goalData) {
    const { title, target_amount, current_amount, target_date, priority } = goalData;
    const database = await db.openDb();
    const sql = `UPDATE savings_goals SET title = ?, target_amount = ?, current_amount = ?, target_date = ?, priority = ? WHERE id = ?`;
    await database.run(sql, [title, target_amount, current_amount, target_date, priority, id]);
    return { id, ...goalData };
  }

  static async delete(id) {
    const database = await db.openDb();
    const sql = `DELETE FROM savings_goals WHERE id = ?`;
    return await database.run(sql, [id]);
  }

  static async findById(id, dbInstance) {
    const database = dbInstance || await db.openDb();
    const sql = `SELECT * FROM savings_goals WHERE id = ?`;
    return await database.get(sql, [id]);
  }

  static async updateBalance(id, amount, dbInstance) {
    const database = dbInstance || await db.openDb();
    const sql = `UPDATE savings_goals SET current_amount = current_amount + ? WHERE id = ?`;
    await database.run(sql, [amount, id]);
  }
}

module.exports = SavingsGoal;
--- FILE: ./server/models/User.js ---
const db = require('../config/database');
const bcrypt = require('bcrypt');
const SALT_ROUNDS = 10;

class User {
  static async create(email, password) {
    const database = await db.openDb();
    const password_hash = await bcrypt.hash(password, SALT_ROUNDS);
    const sql = `INSERT INTO users (email, password_hash) VALUES (?, ?)`;
    const result = await database.run(sql, [email, password_hash]);
    return { id: result.lastID, email };
  }

  static async findByEmail(email) {
    const database = await db.openDb();
    const sql = `SELECT * FROM users WHERE email = ?`;
    return await database.get(sql, [email]);
  }

  static async comparePasswords(plainTextPassword, hashedPassword) {
    return await bcrypt.compare(plainTextPassword, hashedPassword);
  }

  static async count() {
    const database = await db.openDb();
    const result = await database.get('SELECT COUNT(*) as count FROM users');
    return result.count;
  }
}
module.exports = User;
--- FILE: ./server/models/PlannedIncome.js ---
const db = require('../config/database');

class PlannedIncome {
  static async create(incomeData) {
    const { source_name, amount, day_of_month } = incomeData;
    const database = await db.openDb();
    const sql = `INSERT INTO planned_income (source_name, amount, day_of_month) VALUES (?, ?, ?)`;
    const result = await database.run(sql, [source_name, amount, day_of_month]);
    return { id: result.lastID, ...incomeData };
  }

  static async findAllActive() {
    const database = await db.openDb();
    return await database.all('SELECT * FROM planned_income WHERE is_active = 1 ORDER BY day_of_month');
  }

  static async calculateMonthlyTotal() {
    const database = await db.openDb();
    const result = await database.get('SELECT SUM(amount) as total FROM planned_income WHERE is_active = 1');
    return result.total || 0;
  }

  static async update(id, incomeData) {
    const { source_name, amount, day_of_month } = incomeData;
    const database = await db.openDb();
    const sql = `UPDATE planned_income SET source_name = ?, amount = ?, day_of_month = ? WHERE id = ?`;
    await database.run(sql, [source_name, amount, day_of_month, id]);
    return { id, ...incomeData };
  }

  static async deactivate(id) {
    const database = await db.openDb();
    const sql = `UPDATE planned_income SET is_active = 0 WHERE id = ?`;
    return await database.run(sql, [id]);
  }
}

module.exports = PlannedIncome;
--- FILE: ./server/models/RecurringBill.js ---
const db = require('../config/database');

class RecurringBill {
  static async create(billDetails) {
    const { vendor_id, subcategory_id, amount, day_of_month, start_date, notes, end_date } = billDetails;
    const database = await db.openDb();
    const sql = `
      INSERT INTO recurring_bills (vendor_id, subcategory_id, amount, day_of_month, start_date, notes, end_date, is_active)
      VALUES (?, ?, ?, ?, ?, ?, ?, 1)
    `;
    const result = await database.run(sql, [vendor_id, subcategory_id, amount, day_of_month, start_date, notes, end_date]);
    return { id: result.lastID, ...billDetails };
  }

  static async findAllActive() {
    const database = await db.openDb();
    const sql = `
      SELECT
        rb.id, rb.amount, rb.day_of_month, rb.start_date, rb.end_date, rb.notes,
        rb.vendor_id, rb.subcategory_id,
        v.display_name as vendor_name, s.name as subcategory_name
      FROM recurring_bills rb
      JOIN vendors v ON rb.vendor_id = v.id
      JOIN subcategories s ON rb.subcategory_id = s.id
      WHERE rb.is_active = 1
      ORDER BY rb.day_of_month
    `;
    return await database.all(sql);
  }

  static async update(id, newBillDetails) {
    const { vendor_id, subcategory_id, amount, day_of_month, start_date, notes, end_date } = newBillDetails;
    const database = await db.openDb();
    const sql = `UPDATE recurring_bills SET vendor_id = ?, subcategory_id = ?, amount = ?, day_of_month = ?, start_date = ?, notes = ?, end_date = ? WHERE id = ?`;
    await database.run(sql, [vendor_id, subcategory_id, amount, day_of_month, start_date, notes, end_date, id]);
  }


  static async deactivate(id) {
    const database = await db.openDb();
    const sql = `UPDATE recurring_bills SET is_active = 0, end_date = CURRENT_DATE WHERE id = ?`;
    const result = await database.run(sql, [id]);
    return result.changes;
  }
}

module.exports = RecurringBill;
--- FILE: ./server/models/Vendor.js ---
const db = require('../config/database');

class Vendor {
  static async create(name, displayName) {
    const database = await db.openDb();
    const sql = `INSERT INTO vendors (name, display_name) VALUES (?, ?)`;
    const result = await database.run(sql, [name, displayName]);
    return { id: result.lastID, name, displayName };
  }

  static async findAll() {
    const database = await db.openDb();
    const sql = `SELECT * FROM vendors ORDER BY display_name`;
    return await database.all(sql);
  }

  static async findById(id) {
    const database = await db.openDb();
    const sql = `SELECT * FROM vendors WHERE id = ?`;
    return await database.get(sql, [id]);
  }

  static async update(id, name, displayName) {
    const database = await db.openDb();
    const sql = `UPDATE vendors SET name = ?, display_name = ? WHERE id = ?`;
    await database.run(sql, [name, displayName, id]);
    return { id, name, displayName };
  }

  static async delete(id) {
    const database = await db.openDb();
    const sql = `DELETE FROM vendors WHERE id = ?`;
    return await database.run(sql, [id]);
  }
}

module.exports = Vendor;

--- FILE: ./server/models/AppSettings.js ---
const db = require('../config/database');

class AppSettings {
  static async get() {
    const database = await db.openDb();
    return await database.get('SELECT * FROM app_settings WHERE id = 1');
  }

  static async create(fiscal_day_start, jurisdiction) {
    const database = await db.openDb();
    const sql = `
      INSERT INTO app_settings (id, fiscal_day_start, jurisdiction, setup_complete)
      VALUES (1, ?, ?, 1)
      ON CONFLICT(id) DO NOTHING;
    `;
    return await database.run(sql, [fiscal_day_start, jurisdiction]);
  }
}

module.exports = AppSettings;

--- FILE: ./server/models/Category.js ---
const db = require('../config/database');

class Category {
  static async create(name) {
    const database = await db.openDb();
    const sql = `INSERT INTO categories (name) VALUES (?)`;
    const result = await database.run(sql, [name]);
    return { id: result.lastID, name };
  }

  static async findAll() {
    const database = await db.openDb();
    const sql = `SELECT * FROM categories ORDER BY name`;
    return await database.all(sql);
  }

  static async findAllWithSubcategories() {
    const database = await db.openDb();
    const sql = `
      SELECT
        c.id,
        c.name,
        c.linked_savings_account_id,
        (
          SELECT json_group_array(
            json_object('id', s.id, 'name', s.name)
          )
          FROM subcategories s
          WHERE s.category_id = c.id
          ORDER BY s.name
        ) as subcategories
      FROM categories c
      ORDER BY c.name;
    `;
    const categories = await database.all(sql);
    return categories.map(cat => ({
      ...cat,
      subcategories: cat.subcategories ? JSON.parse(cat.subcategories) : []
    }));
  }

  static async findById(id) {
    const database = await db.openDb();
    const sql = `SELECT * FROM categories WHERE id = ?`;
    return await database.get(sql, [id]);
  }

  static async update(id, { name, linked_savings_account_id }) {
    const database = await db.openDb();
    const sql = `UPDATE categories SET name = ?, linked_savings_account_id = ? WHERE id = ?`;
    await database.run(sql, [name, linked_savings_account_id, id]);
    return { id, name, linked_savings_account_id };
  }

  static async delete(id) {
    const database = await db.openDb();
    const sql = `DELETE FROM categories WHERE id = ?`;
    return await database.run(sql, [id]);
  }
}

module.exports = Category;
--- FILE: ./server/models/ImportProfile.js ---
const db = require('../config/database');

class ImportProfile {
  static async findAll() {
    const database = await db.openDb();
    return await database.all('SELECT * FROM import_profiles ORDER BY profile_name');
  }

  static async findById(id) {
    const database = await db.openDb();
    return await database.get('SELECT * FROM import_profiles WHERE id = ?', [id]);
  }

  static async create(profileData) {
    const { profile_name, date_col, description_col, amount_col, debit_col, credit_col, date_format } = profileData;
    const database = await db.openDb();
    const sql = `
        INSERT INTO import_profiles (profile_name, date_col, description_col, amount_col, debit_col, credit_col, date_format) 
        VALUES (?, ?, ?, ?, ?, ?, ?)
    `;
    const result = await database.run(sql, [profile_name, date_col, description_col, amount_col, debit_col, credit_col, date_format]);
    return { id: result.lastID, ...profileData };
  }

  static async update(id, profileData) {
    const { profile_name, date_col, description_col, amount_col, debit_col, credit_col, date_format } = profileData;
    const database = await db.openDb();
    const sql = `
        UPDATE import_profiles SET 
        profile_name = ?, date_col = ?, description_col = ?, amount_col = ?, debit_col = ?, credit_col = ?, date_format = ?
        WHERE id = ?
    `;
    await database.run(sql, [profile_name, date_col, description_col, amount_col, debit_col, credit_col, date_format, id]);
    return { id, ...profileData };
  }

  static async delete(id) {
    const database = await db.openDb();
    await database.run('DELETE FROM import_profiles WHERE id = ?', [id]);
  }
}

module.exports = ImportProfile;
--- FILE: ./server/models/IgnoredTransaction.js ---
const db = require('../config/database');

class IgnoredTransaction {
  static async create(tx, reason) {
    const database = await db.openDb();
    const sql = `
      INSERT INTO ignored_transactions 
      (transaction_date, description_original, amount, is_debit, source_account, reason) 
      VALUES (?, ?, ?, ?, ?, ?)
    `;
    await database.run(sql, [tx.transaction_date, tx.description_original, tx.amount, tx.is_debit, tx.source_account, reason]);
  }

  static async findAll() {
    const database = await db.openDb();
    return await database.all('SELECT * FROM ignored_transactions ORDER BY transaction_date DESC');
  }

  static async findById(id) {
    const database = await db.openDb();
    return await database.get('SELECT * FROM ignored_transactions WHERE id = ?', [id]);
  }

  static async delete(id) {
    const database = await db.openDb();
    await database.run('DELETE FROM ignored_transactions WHERE id = ?', [id]);
  }

  static async deleteAll() {
    const database = await db.openDb();
    await database.run('DELETE FROM ignored_transactions');
  }
}

module.exports = IgnoredTransaction;
--- FILE: ./server/package.json ---
{
  "name": "family-budget-server",
  "version": "1.0.0",
  "description": "Backend server for the Family Budget Management Tool.",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "csv-parser": "^3.0.0",
    "csv-parse": "^5.5.6",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "sqlite": "^5.1.1",
    "sqlite3": "^5.1.6"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}
--- FILE: ./server/controllers/savingsGoalController.js ---
const SavingsAccount = require('../models/SavingsAccount');
const SavingsGoal = require('../models/SavingsGoal');
const Budget = require('../models/Budget');
const { createFinancialMonthService } = require('../services/financialMonthService');

class SavingsController {
  static async createSavingsAccount(req, res) {
    try {
      const account = await SavingsAccount.create(req.body);
      res.status(201).json(account);
    } catch (error) {
      res.status(500).json({ message: 'Error creating savings account.', error: error.message });
    }
  }

  static async getAllSavingsAccounts(req, res) {
    try {
      const accounts = await SavingsAccount.findAll();
      res.status(200).json(accounts);
    } catch (error) {
      res.status(500).json({ message: 'Error fetching savings accounts.', error: error.message });
    }
  }

  static async updateSavingsAccount(req, res) {
    try {
      const account = await SavingsAccount.update(req.params.id, req.body);
      res.status(200).json(account);
    } catch (error) {
      res.status(500).json({ message: 'Error updating savings account.', error: error.message });
    }
  }

  static async deleteSavingsAccount(req, res) {
    try {
      await SavingsAccount.delete(req.params.id);
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ message: 'Error deleting savings account.', error: error.message });
    }
  }

  static async createSavingsGoal(req, res) {
    try {
      const goal = await SavingsGoal.create(req.body);
      res.status(201).json(goal);
    } catch (error) {
      res.status(500).json({ message: 'Error creating savings goal.', error: error.message });
    }
  }

  static async updateSavingsGoal(req, res) {
    try {
      const goal = await SavingsGoal.update(req.params.id, req.body);
      res.status(200).json(goal);
    } catch (error) {
      res.status(500).json({ message: 'Error updating savings goal.', error: error.message });
    }
  }

  static async deleteSavingsGoal(req, res) {
    try {
      await SavingsGoal.delete(req.params.id);
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ message: 'Error deleting savings goal.', error: error.message });
    }
  }

  static async withdrawFromGoal(req, res) {
    const { id } = req.params;
    const { amount, subcategory_id } = req.body;

    const withdrawalAmount = parseFloat(amount);
    if (!withdrawalAmount || !subcategory_id) {
      return res.status(400).json({ message: 'Withdrawal amount and subcategory are required.' });
    }

    if (withdrawalAmount <= 0) {
      return res.status(400).json({ message: 'Withdrawal amount must be a positive number.' });
    }
    
    const db = require('../config/database');
    const database = await db.openDb();

    try {
      await database.exec('BEGIN TRANSACTION');

      const goal = await SavingsGoal.findById(id, database);
      if (!goal) { throw new Error('Savings goal not found.'); }
      
      if (withdrawalAmount > goal.current_amount) {
          throw new Error(`Withdrawal amount cannot exceed the goal balance of ${new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(goal.current_amount)}`);
      }

      const financialMonthService = await createFinancialMonthService();
      const { year, month } = financialMonthService.getCurrentFinancialMonth();
      
      const existingBudget = await Budget.getSingleBudget(subcategory_id, year, month, database);
      
      const newBudgetAmount = (existingBudget ? existingBudget.amount : 0) + withdrawalAmount;
      const budgetPayload = {
          subcategory_id: subcategory_id,
          year: year,
          month: month,
          amount: newBudgetAmount,
          budget_type: existingBudget ? existingBudget.budget_type : 'allowance'
      };

      await Budget.bulkSet([budgetPayload], database);
      await SavingsGoal.updateBalance(id, -withdrawalAmount, database);
      await SavingsAccount.updateBalance(goal.account_id, -withdrawalAmount, database);
      
      await database.exec('COMMIT');
      res.status(200).json({ message: 'Withdrawal successful. Budget has been updated.' });

    } catch (error) {
      await database.exec('ROLLBACK');
      console.error('Error during withdrawal:', error);
      res.status(500).json({ message: error.message || 'Server error during withdrawal.' });
    }
  }
}

module.exports = SavingsController;
--- FILE: ./server/controllers/budgetController.js ---
const Budget = require('../models/Budget');
const Transaction = require('../models/Transaction');
const Subcategory = require('../models/Subcategory');
const { createFinancialMonthService } = require('../services/financialMonthService');
const { parse } = require('csv-parse/sync');

class BudgetController {
  static async setBudgetsBulk(req, res) {
    const { budgets } = req.body;
    if (!budgets || !Array.isArray(budgets)) {
      return res.status(400).json({ message: 'Request must contain an array of budgets.' });
    }
    try {
      await Budget.bulkSet(budgets);
      res.status(200).json({ message: 'Budgets updated successfully.' });
    } catch (error) {
      res.status(500).json({ message: 'Server error updating budgets.' });
    }
  }

  static async getBudgetsByMonth(req, res) {
    const year = parseInt(req.params.year, 10);
    const month = parseInt(req.params.month, 10);
    try {
      const financialMonthService = await createFinancialMonthService();
      const { startDate, endDate } = financialMonthService.getFinancialMonthRange(year, month);

      const [budgets, spending, recurringBills] = await Promise.all([
        Budget.getBudgetsBySubCategoryForMonth(year, month),
        Transaction.getSpendingBySubCategory(startDate, endDate),
        Transaction.getRecurringBillsTotalBySubCategory(endDate, startDate)
      ]);

      const spendingMap = new Map(spending.map(item => [item.subcategory_id, item.actual_spending]));
      const recurringMap = new Map(recurringBills.map(item => [item.subcategory_id, item.total_recurring]));

      const dataWithCarryover = await Promise.all(budgets.map(async (budget) => {
        const carryover = budget.budget_type === 'rolling' ? await Budget.getPreviousMonthSurplus(budget.subcategory_id, year, month) : 0;
        return {
          ...budget,
          actual_spending: spendingMap.get(budget.subcategory_id) || 0,
          recurring_bills_total: recurringMap.get(budget.subcategory_id) || 0,
          carryover_amount: carryover,
        };
      }));

      res.status(200).json(dataWithCarryover);
    } catch (error) {
      console.error('Error fetching budgets:', error);
      res.status(500).json({ message: 'Server error fetching budgets.' });
    }
  }

  static async getBudgetTemplate(req, res) {
    try {
        const subcategories = await Subcategory.findAllWithParent();
        let csvString = "subcategory_id,category_name,subcategory_name";
        
        const today = new Date();
        const year = today.getFullYear();
        const month = today.getMonth();

        for (let i=0; i < 12; i++) {
            const d = new Date(year, month + i, 1);
            csvString += `,${d.toLocaleString('default', { month: 'short' })}-${d.getFullYear()}`;
        }
        csvString += "\n";

        for (const sc of subcategories) {
            csvString += `${sc.id},"${sc.category_name}","${sc.name}"` + ",0.00".repeat(12) + "\n";
        }

        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename="budget_template_forward_12m.csv"`);
        res.status(200).send(csvString);
    } catch (error) {
        res.status(500).json({ message: 'Server error generating budget template.' });
    }
  }

  static async uploadBudget(req, res) {
    if (!req.file) { return res.status(400).json({ message: 'No file uploaded.' }); }
    try {
        const records = parse(req.file.buffer, {
            columns: true,
            skip_empty_lines: true,
            trim: true,
        });

        const budgetsToSave = [];
        const today = new Date();

        for(const rec of records) {
            for(let i=0; i < 12; i++) {
                const d = new Date(today.getFullYear(), today.getMonth() + i, 1);
                const year = d.getFullYear();
                const month = d.getMonth() + 1;
                const monthShort = d.toLocaleString('default', { month: 'short' });
                const header = `${monthShort}-${year}`;
                
                if (rec[header]) {
                    budgetsToSave.push({
                        subcategory_id: parseInt(rec.subcategory_id, 10),
                        year: year,
                        month: month,
                        amount: parseFloat(rec[header] || 0),
                        budget_type: 'allowance' // Default, can be changed in UI
                    });
                }
            }
        }

        if (budgetsToSave.some(b => isNaN(b.subcategory_id) || isNaN(b.year) || isNaN(b.month) || isNaN(b.amount))) {
            return res.status(400).json({ message: 'CSV contains invalid or malformed data.' });
        }

        await Budget.bulkSet(budgetsToSave);
        res.status(200).json({ message: `Successfully uploaded and saved ${budgetsToSave.length} budget entries.` });
    } catch (error) {
        res.status(500).json({ message: `Error processing CSV file: ${error.message}` });
    }
  }
}

module.exports = BudgetController;
--- FILE: ./server/controllers/forecastController.js ---
const ForecastService = require('../services/forecastService');

class ForecastController {
  static async getCashflowForecast(req, res) {
    try {
      const forecast = await ForecastService.generateForecast();
      res.status(200).json(forecast);
    } catch (error) {
      console.error('Error generating cashflow forecast:', error);
      res.status(500).json({ message: 'Server error generating cashflow forecast.' });
    }
  }
}

module.exports = ForecastController;

--- FILE: ./server/controllers/vendorController.js ---
const Vendor = require('../models/Vendor');

class VendorController {
  static async createVendor(req, res) {
    const { name, displayName } = req.body;
    if (!name || !displayName) {
      return res.status(400).json({ message: 'Vendor name and displayName are required.' });
    }
    try {
      const newVendor = await Vendor.create(name, displayName);
      res.status(201).json(newVendor);
    } catch (error) {
      if (error.code === 'SQLITE_CONSTRAINT') {
        return res.status(409).json({ message: `Vendor '${name}' already exists.` });
      }
      res.status(500).json({ message: 'Server error creating vendor.' });
    }
  }

  static async getAllVendors(req, res) {
    try {
      const vendors = await Vendor.findAll();
      res.status(200).json(vendors);
    } catch (error) {
      res.status(500).json({ message: 'Server error fetching vendors.' });
    }
  }

  static async updateVendor(req, res) {
    const { id } = req.params;
    const { name, displayName } = req.body;
    if (!name || !displayName) {
      return res.status(400).json({ message: 'Vendor name and displayName are required.' });
    }
    try {
      const vendor = await Vendor.findById(id);
      if (!vendor) {
        return res.status(404).json({ message: 'Vendor not found.' });
      }
      const updatedVendor = await Vendor.update(id, name, displayName);
      res.status(200).json(updatedVendor);
    } catch (error) {
      res.status(500).json({ message: 'Server error updating vendor.' });
    }
  }

  static async deleteVendor(req, res) {
    const { id } = req.params;
    try {
      const vendor = await Vendor.findById(id);
      if (!vendor) {
        return res.status(404).json({ message: 'Vendor not found.' });
      }
      await Vendor.delete(id);
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ message: 'Server error deleting vendor.' });
    }
  }
}

module.exports = VendorController;

--- FILE: ./server/controllers/backupController.js ---
const path = require('path');
const fs = require('fs');
const db = require('../config/database');

const DB_PATH = path.join(__dirname, '..', 'data', 'sqlite', 'budget.db');

class BackupController {
  static createBackup(req, res) {
    if (fs.existsSync(DB_PATH)) {
      res.setHeader('Content-Disposition', 'attachment; filename=budget_backup.db');
      res.setHeader('Content-Type', 'application/x-sqlite3');
      res.download(DB_PATH, 'budget_backup.db', (err) => {
        if (err) {
          console.error('Error downloading database:', err);
          if (!res.headersSent) {
            res.status(500).json({ message: "Could not download the database." });
          }
        }
      });
    } else {
      res.status(404).json({ message: "Database file not found." });
    }
  }

  static async restoreBackup(req, res) {
    if (!req.file) {
      return res.status(400).json({ message: 'No backup file uploaded.' });
    }

    const tempPath = req.file.path;
    const dbDir = path.dirname(DB_PATH);

    try {
      // Close the existing database connection to release the file lock.
      await db.closeDb();
      console.log('Database connection closed for restore.');

      // Ensure the target directory exists.
      if (!fs.existsSync(dbDir)) {
        fs.mkdirSync(dbDir, { recursive: true });
      }

      // Copy the file, then delete the temporary one. This avoids the EXDEV error.
      fs.copyFileSync(tempPath, DB_PATH);
      fs.unlinkSync(tempPath); 
      console.log('Database file replaced successfully.');

      res.status(200).json({ message: 'Restore successful. The application is restarting...' });
      
      // Exit the process after a short delay. Docker will restart it automatically.
      setTimeout(() => {
        console.log('Exiting process for restart...');
        process.exit(1);
      }, 500);

    } catch (error) {
        console.error('Error during database restore:', error);
        // Clean up the temporary file if it still exists
        if (fs.existsSync(tempPath)) {
          fs.unlinkSync(tempPath);
        }
        res.status(500).json({ message: `Failed to restore backup: ${error.message}` });
    }
  }
}

module.exports = BackupController;
--- FILE: ./server/controllers/dashboardController.js ---
const Transaction = require('../models/Transaction');
const Budget = require('../models/Budget');
const PlannedIncome = require('../models/PlannedIncome');
const SavingsAccount = require('../models/SavingsAccount');
const { createFinancialMonthService } = require('../services/financialMonthService');
const ForecastService = require('../services/forecastService');

class DashboardController {
  static async getDashboardData(req, res) {
    try {
      const financialMonthService = await createFinancialMonthService();
      // If setup is not complete, return empty data to prevent a crash.
      if (!financialMonthService) {
        return res.status(200).json({
          summary: { totalIncome: 0, totalSpending: 0, plannedSurplus: 0, currentSurplus: 0 },
          incomeStatus: [],
          inMonthCashflow: [],
          twelveMonthForecast: [],
          savingsGoals: [],
          budgetVsActual: [],
          topVendors: [],
        });
      }

      const { year, month, startDate, endDate } = financialMonthService.getCurrentFinancialMonth(); 
      
      const [
        allTransactions,
        allBudgets,
        allPlannedIncomes,
        allSavingsAccounts,
        twelveMonthForecast,
        topVendors,
        spendingByCategory
      ] = await Promise.all([
        Transaction.findAllByDateRange(startDate, endDate),
        Budget.getBudgetsBySubCategoryForMonth(year, month),
        PlannedIncome.findAllActive(),
        SavingsAccount.findAll(),
        ForecastService.generateForecast(),
        Transaction.getTopVendorsByTransactionCount(startDate, endDate),
        Transaction.getSpendingByCategory(startDate, endDate)
      ]);

      const totalIncome = allTransactions.filter(t => !t.is_debit && t.transaction_type === 'income').reduce((sum, t) => sum + t.amount, 0);
      const totalSpending = allTransactions.filter(t => t.is_debit).reduce((sum, t) => sum + t.amount, 0);
      
      const plannedIncomeTotal = allPlannedIncomes.reduce((sum, i) => sum + i.amount, 0);
      const totalBudgeted = allBudgets.reduce((sum, b) => sum + b.budgeted_amount, 0);
      const plannedSurplus = plannedIncomeTotal - totalBudgeted;

      const receivedIncomes = allPlannedIncomes.map(pi => {
        const received = allTransactions.some(t => !t.is_debit && t.description_original.toLowerCase().includes(pi.source_name.toLowerCase()));
        return { ...pi, received };
      });

      const spendingMap = new Map();
      allTransactions.filter(t => t.is_debit).forEach(t => {
          if (t.subcategory_id) {
              spendingMap.set(t.subcategory_id, (spendingMap.get(t.subcategory_id) || 0) + t.amount);
          }
      });
      
      const budgetOverspends = allBudgets.reduce((acc, budget) => {
        const spendingForSubcategory = spendingMap.get(budget.subcategory_id) || 0;
        if (spendingForSubcategory > budget.budgeted_amount) {
            acc += (spendingForSubcategory - budget.budgeted_amount);
        }
        return acc;
      }, 0);

      const currentSurplus = totalIncome - totalSpending;
      
      const inMonthCashflow = [];
      let runningBalance = 0;
      const daysInMonth = (new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24);
      let currentDate = new Date(startDate);

      for (let i = 0; i <= daysInMonth; i++) {
          const isoDate = currentDate.toISOString().split('T')[0];
          
          const dailyInflow = allTransactions.filter(t => !t.is_debit && t.transaction_date === isoDate).reduce((sum, t) => sum + t.amount, 0);
          const dailyOutflow = allTransactions.filter(t => t.is_debit && t.transaction_date === isoDate).reduce((sum, t) => sum + t.amount, 0);

          runningBalance += dailyInflow - dailyOutflow;
          inMonthCashflow.push({ date: isoDate, actual: runningBalance });
          currentDate.setDate(currentDate.getDate() + 1);
      }

      const categoryMap = new Map();
      allBudgets.forEach(b => {
          if (!categoryMap.has(b.category_id)) {
              categoryMap.set(b.category_id, { category_name: b.category_name, budgeted: 0, actual: 0 });
          }
          let categoryData = categoryMap.get(b.category_id);
          categoryData.budgeted += b.budgeted_amount;
      });

      spendingByCategory.forEach(s => {
          if (categoryMap.has(s.category_id)) {
              categoryMap.get(s.category_id).actual += s.actual_spending;
          } else {
              categoryMap.set(s.category_id, { category_name: s.category_name, budgeted: 0, actual: s.actual_spending });
          }
      });

      const dashboardData = {
        summary: {
            totalIncome,
            totalSpending,
            plannedSurplus,
            currentSurplus
        },
        incomeStatus: receivedIncomes,
        inMonthCashflow,
        twelveMonthForecast,
        savingsGoals: allSavingsAccounts.flatMap(acc => acc.goals),
        budgetVsActual: Array.from(categoryMap.values()),
        topVendors: topVendors,
      };

      res.status(200).json(dashboardData);

    } catch (error) {
      console.error('Error fetching dashboard data:', error);
      res.status(500).json({ message: 'Server error fetching dashboard data.' });
    }
  }
}

module.exports = DashboardController;
--- FILE: ./server/controllers/categoryController.js ---
const Category = require('../models/Category');
const Subcategory = require('../models/Subcategory');

class CategoryController {
  static async createCategory(req, res) {
    const { name } = req.body;
    if (!name) {
      return res.status(400).json({ message: 'Category name is required.' });
    }
    try {
      const newCategory = await Category.create(name);
      res.status(201).json(newCategory);
    } catch (error) {
      if (error.code === 'SQLITE_CONSTRAINT') {
        return res.status(409).json({ message: `Category '${name}' already exists.` });
      }
      res.status(500).json({ message: 'Server error creating category.' });
    }
  }

  static async createSubcategory(req, res) {
    const { categoryId } = req.params;
    const { name } = req.body;
    if (!name) {
        return res.status(400).json({ message: 'Subcategory name is required.' });
    }
    try {
        const newSubcategory = await Subcategory.create(name, categoryId);
        res.status(201).json(newSubcategory);
    } catch (error) {
        if (error.code === 'SQLITE_CONSTRAINT') {
          return res.status(409).json({ message: `Subcategory '${name}' already exists in this category.` });
        }
        res.status(500).json({ message: 'Server error creating subcategory.' });
    }
  }

  static async getAllCategories(req, res) {
    try {
      if (req.query.with_subcategories === 'true') {
        const categories = await Category.findAllWithSubcategories();
        return res.status(200).json(categories);
      } else {
        const categories = await Category.findAll();
        return res.status(200).json(categories);
      }
    } catch (error) {
      console.error("Error fetching categories:", error);
      res.status(500).json({ message: 'Server error fetching categories.' });
    }
  }

  static async updateCategory(req, res) {
    const { id } = req.params;
    const { name, linked_savings_account_id } = req.body;
    if (!name) {
        return res.status(400).json({ message: 'Category name is required.' });
    }
    try {
        const category = await Category.findById(id);
        if (!category) {
            return res.status(404).json({ message: 'Category not found.' });
        }
        const updatedCategory = await Category.update(id, { name, linked_savings_account_id });
        res.status(200).json(updatedCategory);
    } catch (error) {
        res.status(500).json({ message: 'Server error updating category.' });
    }
  }

  static async deleteCategory(req, res) {
    const { id } = req.params;
    try {
      await Category.delete(id);
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ message: 'Server error deleting category.' });
    }
  }

  static async deleteSubcategory(req, res) {
    const { subcategoryId } = req.params;
    try {
      await Subcategory.delete(subcategoryId);
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ message: 'Server error deleting subcategory.' });
    }
  }
}

module.exports = CategoryController;
--- FILE: ./server/controllers/settingsController.js ---
const AppSettings = require('../models/AppSettings');
const HolidayService = require('../services/holidayService');

class SettingsController {
  static async getSettings(req, res) {
    try {
      const settings = await AppSettings.get();
      res.status(200).json(settings || {});
    } catch (error) {
      res.status(500).json({ message: 'Server error fetching settings.' });
    }
  }

  static async saveSettings(req, res) {
    const { fiscal_day_start, jurisdiction } = req.body;
    if (!fiscal_day_start || !jurisdiction) {
      return res.status(400).json({ message: 'Fiscal start day and jurisdiction are required.' });
    }
    try {
      const existingSettings = await AppSettings.get();
      if (existingSettings && existingSettings.setup_complete) {
        return res.status(403).json({ message: 'Initial setup has already been completed and cannot be changed.' });
      }
      await AppSettings.create(fiscal_day_start, jurisdiction);
      await HolidayService.fetchAndStoreHolidays(jurisdiction);
      res.status(201).json({ message: 'Settings saved successfully.' });
    } catch (error) {
      console.error("Error saving settings:", error);
      res.status(500).json({ message: 'Server error saving settings.' });
    }
  }

  static async refreshHolidays(req, res) {
    try {
      const settings = await AppSettings.get();
      if (!settings || !settings.jurisdiction) {
        return res.status(400).json({ message: 'Jurisdiction not set. Cannot refresh holidays.' });
      }
      await HolidayService.fetchAndStoreHolidays(settings.jurisdiction);
      res.status(200).json({ message: 'Public holidays have been successfully updated.' });
    } catch (error) {
        console.error("Error refreshing holidays:", error);
        res.status(500).json({ message: 'Server error refreshing holidays.' });
    }
  }
}

module.exports = SettingsController;
--- FILE: ./server/controllers/importProfileController.js ---
const ImportProfile = require('../models/ImportProfile');

class ImportProfileController {
  static async getAllProfiles(req, res) {
    try {
      const profiles = await ImportProfile.findAll();
      res.status(200).json(profiles);
    } catch (error) {
      res.status(500).json({ message: 'Error fetching import profiles.', error: error.message });
    }
  }

  static async createProfile(req, res) {
    try {
      const profile = await ImportProfile.create(req.body);
      res.status(201).json(profile);
    } catch (error) {
      res.status(500).json({ message: 'Error creating import profile.', error: error.message });
    }
  }

  static async updateProfile(req, res) {
    try {
      const profile = await ImportProfile.update(req.params.id, req.body);
      res.status(200).json(profile);
    } catch (error) {
      res.status(500).json({ message: 'Error updating import profile.', error: error.message });
    }
  }

  static async deleteProfile(req, res) {
    try {
      await ImportProfile.delete(req.params.id);
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ message: 'Error deleting import profile.', error: error.message });
    }
  }
}

module.exports = ImportProfileController;
--- FILE: ./server/controllers/subcategoryController.js ---
const Subcategory = require('../models/Subcategory');

const SubcategoryController = {
  getAllSubcategoriesWithParent: async (req, res) => {
    try {
      const subcategories = await Subcategory.findAllWithParent();
      res.status(200).json(subcategories);
    } catch (error) {
      console.error('Error fetching all subcategories:', error);
      res.status(500).json({ message: 'Server error fetching subcategories.' });
    }
  }
};

module.exports = SubcategoryController;

--- FILE: ./server/controllers/plannedIncomeController.js ---
const PlannedIncome = require('../models/PlannedIncome');

class PlannedIncomeController {
  static async createIncome(req, res) {
    try {
      const income = await PlannedIncome.create(req.body);
      res.status(201).json(income);
    } catch (error) {
      res.status(500).json({ message: 'Error creating planned income.', error: error.message });
    }
  }

  static async getActiveIncome(req, res) {
    try {
      const income = await PlannedIncome.findAllActive();
      res.status(200).json(income);
    } catch (error) {
      res.status(500).json({ message: 'Error fetching planned income.', error: error.message });
    }
  }

  static async updateIncome(req, res) {
    try {
      const income = await PlannedIncome.update(req.params.id, req.body);
      res.status(200).json(income);
    } catch (error) {
      res.status(500).json({ message: 'Error updating planned income.', error: error.message });
    }
  }

  static async deactivateIncome(req, res) {
    try {
      await PlannedIncome.deactivate(req.params.id);
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ message: 'Error deactivating planned income.', error: error.message });
    }
  }
}

module.exports = PlannedIncomeController;
--- FILE: ./server/controllers/authController.js ---
const User = require('../models/User');
const jwt = require('jsonwebtoken');
const JWT_SECRET = 'your-super-secret-key-that-is-long-and-random';

class AuthController {
  static async register(req, res) {
    const { email, password } = req.body;
    if (!email || !password) {
      return res.status(400).json({ message: 'Email and password are required.' });
    }
    try {
      const userCount = await User.count();
      if (userCount > 0) {
        return res.status(403).json({ message: 'Registration is not allowed. An admin user already exists.' });
      }
      const newUser = await User.create(email, password);
      res.status(201).json({ message: 'User created successfully.', userId: newUser.id });
    } catch (error) {
      res.status(500).json({ message: 'Internal server error during registration.' });
    }
  }

  static async login(req, res) {
    const { email, password } = req.body;
    if (!email || !password) {
      return res.status(400).json({ message: 'Email and password are required.' });
    }
    try {
      const user = await User.findByEmail(email);
      if (!user) {
        return res.status(401).json({ message: 'Invalid credentials.' });
      }
      const isMatch = await User.comparePasswords(password, user.password_hash);
      if (!isMatch) {
        return res.status(401).json({ message: 'Invalid credentials.' });
      }
      const token = jwt.sign({ id: user.id, email: user.email }, JWT_SECRET, { expiresIn: '7d' });
      res.status(200).json({ message: 'Login successful.', token, user: { id: user.id, email: user.email } });
    } catch (error) {
      res.status(500).json({ message: 'Internal server error during login.' });
    }
  }
}
module.exports = AuthController;
--- FILE: ./server/controllers/recurringBillController.js ---
const RecurringBill = require('../models/RecurringBill');

class RecurringBillController {
  static async createBill(req, res) {
    const { vendor_id, subcategory_id, amount, day_of_month, start_date } = req.body;
    if (!vendor_id || !subcategory_id || !amount || !day_of_month || !start_date) {
      return res.status(400).json({ message: 'Missing required fields for recurring bill.' });
    }
    try {
      const newBill = await RecurringBill.create(req.body);
      res.status(201).json(newBill);
    } catch (error) {
      console.error('Error creating recurring bill:', error);
      res.status(500).json({ message: 'Server error creating recurring bill.' });
    }
  }

  static async getActiveBills(req, res) {
    try {
      const bills = await RecurringBill.findAllActive();
      res.status(200).json(bills);
    } catch (error) {
      console.error('Error fetching recurring bills:', error);
      res.status(500).json({ message: 'Server error fetching recurring bills.' });
    }
  }

  static async updateBill(req, res) {
    const { id } = req.params;
    const newBillDetails = req.body;
    try {
      // The original code was calling a non-existent function "updateAndSupersede".
      // This has been corrected to call the standard "update" function.
      await RecurringBill.update(id, newBillDetails);
      const updatedBill = { id, ...newBillDetails };
      res.status(200).json(updatedBill);
    } catch (error) {
      console.error('Error updating recurring bill:', error);
      res.status(500).json({ message: 'Server error updating recurring bill.' });
    }
  }

  static async deactivateBill(req, res) {
    const { id } = req.params;
    try {
      const changes = await RecurringBill.deactivate(id);
      if (changes === 0) {
        return res.status(404).json({ message: 'Recurring bill not found.' });
      }
      res.status(200).json({ message: 'Recurring bill deactivated successfully.' });
    } catch (error) {
      console.error('Error deactivating recurring bill:', error);
      res.status(500).json({ message: 'Server error deactivating recurring bill.' });
    }
  }
}

module.exports = RecurringBillController;
--- FILE: ./server/controllers/transactionController.js ---
const CsvParserService = require('../services/csvParserService');
const VendorNormalizationService = require('../services/vendorNormalizationService');
const Transaction = require('../models/Transaction');
const IgnoredTransaction = require('../models/IgnoredTransaction');
const CategorizationRule = require('../models/CategorizationRule');
const SplitTransaction = require('../models/SplitTransaction');
const db = require('../config/database');


class TransactionController {
  static async uploadTransactions(req, res) {
    if (!req.file) { return res.status(400).json({ message: 'No file uploaded.' }); }
    
    try {
      const { profileId } = req.body;
      if(!profileId) { return res.status(400).json({ message: 'No import profile selected.' }); }

      // Use req.file.buffer which is available when using multer's memoryStorage
      const parsedTransactions = await CsvParserService.parse(req.file.buffer, profileId);
      
      const formattedTransactions = [];
      for(const tx of parsedTransactions) {
        const vendorId = await VendorNormalizationService.normalize(tx.description);
        let subcategoryId = null;
        if (vendorId) {
            const rule = await CategorizationRule.findRuleByVendor(vendorId);
            if (rule) { subcategoryId = rule.subcategory_id; }
        }

        formattedTransactions.push({
          transaction_date: tx.date,
          description_original: tx.description,
          amount: Math.abs(tx.amount),
          is_debit: tx.amount < 0,
          source_account: tx.source,
          vendor_id: vendorId,
          subcategory_id: subcategoryId,
        });
      }

      const validTransactions = formattedTransactions.filter(tx => tx.transaction_date && tx.amount > 0);
      let newCount = 0;
      let ignoredCount = 0;

      for (const tx of validTransactions) {
        const isDuplicate = await Transaction.exists(tx);
        if (!isDuplicate) { 
          await Transaction.create(tx);
          newCount++;
        } else {
          await IgnoredTransaction.create(tx, 'Potential Duplicate');
          ignoredCount++;
        }
      }

      res.status(201).json({ message: `Successfully saved ${newCount} new transactions. Ignored ${ignoredCount} duplicates.` });
    } catch (error) {
      console.error(error)
      res.status(500).json({ message: error.message || 'Error processing file.' });
    }
  }

  static async applyRules(req, res) {
    try {
        const changes = await Transaction.applyCategorizationRules();
        res.status(200).json({ message: `Successfully categorized ${changes} transactions based on your existing rules.` });
    } catch (error) {
        console.error("Error applying categorization rules:", error);
        res.status(500).json({ message: 'Server error applying categorization rules.' });
    }
  }
  
  static async getIgnoredTransactions(req, res) {
    try {
      const transactions = await IgnoredTransaction.findAll();
      res.status(200).json(transactions);
    } catch (error) {
      res.status(500).json({ message: 'Server error fetching ignored transactions.' });
    }
  }

  static async reinstateTransaction(req, res) {
    try {
      const ignoredTx = await IgnoredTransaction.findById(req.params.id);
      if (!ignoredTx) {
        return res.status(404).json({ message: 'Ignored transaction not found.' });
      }

      const { id, reason, created_at, ...txToCreate } = ignoredTx;
      await Transaction.create(txToCreate);
      await IgnoredTransaction.delete(req.params.id);
      res.status(200).json({ message: 'Transaction reinstated.' });
    } catch (error) {
      res.status(500).json({ message: 'Error reinstating transaction.' });
    }
  }

  static async purgeIgnoredTransactions(req, res) {
    try {
      await IgnoredTransaction.deleteAll();
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ message: 'Error purging ignored transactions.' });
    }
  }

  static async getAllTransactions(req, res) {
    try {
      const transactions = await Transaction.findAll();
      res.status(200).json(transactions);
    } catch (error) { res.status(500).json({ message: 'Server error fetching transactions.' }); }
  }

  static async getUncategorizedTransactions(req, res) {
    try {
      const transactions = await Transaction.findUncategorized();
      res.status(200).json(transactions);
    } catch (error) { res.status(500).json({ message: 'Server error fetching uncategorized transactions.' }); }
  }

  static async categorizeTransaction(req, res) {
    const { id } = req.params;
    const { subcategory_id, transaction_type } = req.body;

    try {
      if (subcategory_id !== undefined) { 
        await Transaction.updateCategory(id, subcategory_id);
        const transaction = await Transaction.findById(id);
        if (transaction && transaction.vendor_id && subcategory_id) {
          await CategorizationRule.createOrUpdateRule(transaction.vendor_id, subcategory_id);
        }
      }
      
      if (transaction_type) {
        await Transaction.updateType(id, transaction_type);
      }

      res.status(200).json({ message: 'Transaction updated successfully.' });
    } catch (error) { 
      console.error("Error categorizing transaction:", error);
      res.status(500).json({ message: 'Server error categorizing transaction.' }); 
    }
  }

  static async updateTransactionVendor(req, res) {
    const { id } = req.params;
    const { vendor_id } = req.body;
    if (!vendor_id) { return res.status(400).json({ message: 'Vendor ID is required.' }); }
    try {
      const changes = await Transaction.updateVendor(id, vendor_id);
      if (changes === 0) { return res.status(404).json({ message: 'Transaction not found.' }); }
      res.status(200).json({ message: 'Transaction vendor updated successfully.' });
    } catch (error) { res.status(500).json({ message: 'Server error updating transaction vendor.' }); }
  }

  static async splitTransaction(req, res) {
    const { id } = req.params;
    const { splits, vendor_id } = req.body;

    if (!splits || !Array.isArray(splits) || splits.length < 2) { 
      return res.status(400).json({ message: 'A split must contain at least two items.' }); 
    }

    const database = await db.openDb();
    try {
      await database.exec('BEGIN TRANSACTION');
      const parentTx = await Transaction.findById(id, database);
      if (!parentTx) { throw new Error('Parent transaction not found.'); }
      
      const totalSplitAmount = splits.reduce((sum, s) => sum + parseFloat(s.amount || 0), 0);
      if (Math.abs(totalSplitAmount - parentTx.amount) > 0.01) { throw new Error(`Split amounts (${totalSplitAmount.toFixed(2)}) do not match the parent transaction amount (${parentTx.amount.toFixed(2)}).`); }
      
      if (vendor_id && vendor_id !== parentTx.vendor_id.toString()) {
        await Transaction.updateVendor(id, vendor_id, database);
      }

      await SplitTransaction.deleteByTransactionId(id, database);
      await Transaction.markAsSplit(id, database);
      await SplitTransaction.bulkCreate(id, splits, database);

      await database.exec('COMMIT');
      res.status(200).json({ message: 'Transaction split successfully.' });
    } catch (error) {
      await database.exec('ROLLBACK');
      res.status(500).json({ message: error.message || 'Server error splitting transaction.' });
    }
  }
}

module.exports = TransactionController;
--- FILE: ./server/routes/subcategories.js ---
const express = require('express');
const router = express.Router();
const SubcategoryController = require('../controllers/subcategoryController');
const isAuthenticated = require('../middleware/isAuthenticated');

router.use(isAuthenticated);

router.get('/all', SubcategoryController.getAllSubcategoriesWithParent);

module.exports = router;

--- FILE: ./server/routes/categories.js ---
const express = require('express');
const router = express.Router();
const CategoryController = require('../controllers/categoryController');
const isAuthenticated = require('../middleware/isAuthenticated');

router.use(isAuthenticated);

router.get('/', CategoryController.getAllCategories);
router.post('/', CategoryController.createCategory);
router.delete('/:id', CategoryController.deleteCategory);
router.post('/:categoryId/subcategories', CategoryController.createSubcategory);
router.delete('/:categoryId/subcategories/:subcategoryId', CategoryController.deleteSubcategory);

module.exports = router;

--- FILE: ./server/routes/transactions.js ---
const express = require('express');
const router = express.Router();
const multer = require('multer');
const TransactionController = require('../controllers/transactionController');
const isAuthenticated = require('../middleware/isAuthenticated');

// Use memory storage for multer to handle the file buffer directly
const storage = multer.memoryStorage();
const upload = multer({ storage: storage });

router.use(isAuthenticated);

// The upload middleware now uses memory storage
router.post('/upload', upload.single('transactionsFile'), TransactionController.uploadTransactions);
router.post('/apply-rules', TransactionController.applyRules);

router.get('/', TransactionController.getAllTransactions);
router.get('/uncategorized', TransactionController.getUncategorizedTransactions);
router.put('/:id/categorize', TransactionController.categorizeTransaction);
router.put('/:id/vendor', TransactionController.updateTransactionVendor);
router.post('/:id/split', TransactionController.splitTransaction);

router.get('/ignored', TransactionController.getIgnoredTransactions);
router.post('/ignored/:id/reinstate', TransactionController.reinstateTransaction);
router.delete('/ignored/purge', TransactionController.purgeIgnoredTransactions);

module.exports = router;
--- FILE: ./server/routes/backup.js ---
const express = require('express');
const router = express.Router();
const multer = require('multer');
const BackupController = require('../controllers/backupController');
const isAuthenticated = require('../middleware/isAuthenticated');

// Configure multer for temporary file storage
const upload = multer({ dest: 'data/uploads/' });

// Backup must be authenticated
router.get('/create', isAuthenticated, BackupController.createBackup);

// Restore is public to be accessible from the setup page
router.post('/restore', upload.single('backupFile'), BackupController.restoreBackup);

module.exports = router;
--- FILE: ./server/routes/vendors.js ---
const express = require('express');
const router = express.Router();
const VendorController = require('../controllers/vendorController');
const isAuthenticated = require('../middleware/isAuthenticated');

router.use(isAuthenticated);

router.post('/', VendorController.createVendor);
router.get('/', VendorController.getAllVendors);
router.put('/:id', VendorController.updateVendor);
router.delete('/:id', VendorController.deleteVendor);

module.exports = router;

--- FILE: ./server/routes/auth.js ---
const express = require('express');
const router = express.Router();
const AuthController = require('../controllers/authController');

router.post('/register', AuthController.register);
router.post('/login', AuthController.login);

module.exports = router;

--- FILE: ./server/routes/importProfiles.js ---
const express = require('express');
const router = express.Router();
const ImportProfileController = require('../controllers/importProfileController');
const isAuthenticated = require('../middleware/isAuthenticated');

router.use(isAuthenticated);

router.get('/', ImportProfileController.getAllProfiles);
router.post('/', ImportProfileController.createProfile);
router.put('/:id', ImportProfileController.updateProfile);
router.delete('/:id', ImportProfileController.deleteProfile);

module.exports = router;
--- FILE: ./server/routes/plannedIncome.js ---
const express = require('express');
const router = express.Router();
const PlannedIncomeController = require('../controllers/plannedIncomeController');
const isAuthenticated = require('../middleware/isAuthenticated');

router.use(isAuthenticated);

router.post('/', PlannedIncomeController.createIncome);
router.get('/', PlannedIncomeController.getActiveIncome);
router.put('/:id', PlannedIncomeController.updateIncome);
router.delete('/:id', PlannedIncomeController.deactivateIncome);

module.exports = router;
--- FILE: ./server/routes/forecast.js ---
const express = require('express');
const router = express.Router();
const ForecastController = require('../controllers/forecastController');
const isAuthenticated = require('../middleware/isAuthenticated');

router.use(isAuthenticated);

router.get('/cashflow', ForecastController.getCashflowForecast);

module.exports = router;

--- FILE: ./server/routes/recurringBills.js ---
const express = require('express');
const router = express.Router();
const RecurringBillController = require('../controllers/recurringBillController');
const isAuthenticated = require('../middleware/isAuthenticated');

router.use(isAuthenticated);

router.post('/', RecurringBillController.createBill);
router.get('/', RecurringBillController.getActiveBills);
router.put('/:id', RecurringBillController.updateBill);
router.delete('/:id', RecurringBillController.deactivateBill);

module.exports = router;

--- FILE: ./server/routes/dashboard.js ---
const express = require('express');
const router = express.Router();
const DashboardController = require('../controllers/dashboardController');
const isAuthenticated = require('../middleware/isAuthenticated');

router.use(isAuthenticated);

// This is the new, single endpoint for the rebuilt dashboard
router.get('/', DashboardController.getDashboardData);

module.exports = router;
--- FILE: ./server/routes/budgets.js ---
const express = require('express');
const router = express.Router();
const BudgetController = require('../controllers/budgetController');
const isAuthenticated = require('../middleware/isAuthenticated');
const multer = require('multer');
const storage = multer.memoryStorage();
const upload = multer({ storage: storage });

router.use(isAuthenticated);

router.post('/bulk', BudgetController.setBudgetsBulk);
router.get('/:year/:month', BudgetController.getBudgetsByMonth);
router.get('/template', BudgetController.getBudgetTemplate);
router.post('/upload', upload.single('budgetFile'), BudgetController.uploadBudget);

module.exports = router;

--- FILE: ./server/routes/settings.js ---
const express = require('express');
const router = express.Router();
const SettingsController = require('../controllers/settingsController');
const isAuthenticated = require('../middleware/isAuthenticated');

// PUBLIC ROUTE: Check settings BEFORE login to see if setup is complete.
router.get('/', SettingsController.getSettings);

// PROTECTED ROUTES: You must be logged in to change settings.
router.post('/', isAuthenticated, SettingsController.saveSettings);
router.post('/refresh-holidays', isAuthenticated, SettingsController.refreshHolidays);

module.exports = router;
--- FILE: ./server/routes/savingsGoals.js ---
const express = require('express');
const router = express.Router();
const SavingsController = require('../controllers/savingsGoalController');
const isAuthenticated = require('../middleware/isAuthenticated');

router.use(isAuthenticated);

// Savings Accounts
router.post('/accounts', SavingsController.createSavingsAccount);
router.get('/accounts', SavingsController.getAllSavingsAccounts);
router.put('/accounts/:id', SavingsController.updateSavingsAccount);
router.delete('/accounts/:id', SavingsController.deleteSavingsAccount);

// Savings Goals
router.post('/goals', SavingsController.createSavingsGoal);
router.put('/goals/:id', SavingsController.updateSavingsGoal);
router.delete('/goals/:id', SavingsController.deleteSavingsGoal);
router.post('/goals/:id/withdraw', SavingsController.withdrawFromGoal);

module.exports = router;
--- FILE: ./server/services/dateHelpers.js ---
const PublicHoliday = require('../models/PublicHoliday');

async function getHolidays() {
    return await PublicHoliday.getAllAsSet();
}

function isWeekend(date) {
    const day = date.getDay();
    return day === 0 || day === 6;
}

function getPreviousWorkday(date, holidays) {
    let newDate = new Date(date);
    const isoDate = () => newDate.toISOString().split('T')[0];
    while (isWeekend(newDate) || holidays.has(isoDate())) {
        newDate.setDate(newDate.getDate() - 1);
    }
    return newDate;
}

module.exports = { isWeekend, getPreviousWorkday, getHolidays };
--- FILE: ./server/services/vendorNormalizationService.js ---
const Vendor = require('../models/Vendor');
const db = require('../config/database');

const NORMALIZATION_RULES = {
  'tesco': ['tesco'],
  'amazon': ['amazon', 'amzn'],
  'costa coffee': ['costa'],
  'netflix': ['netflix.com']
};

class VendorNormalizationService {
  static async normalize(description) {
    const lowerCaseDesc = description.toLowerCase();
    const database = await db.openDb();

    for (const vendorName in NORMALIZATION_RULES) {
      const keywords = NORMALIZATION_RULES[vendorName];
      if (keywords.some(keyword => lowerCaseDesc.includes(keyword))) {
        let vendor = await database.get('SELECT * FROM vendors WHERE name = ?', vendorName);
        if (!vendor) {
          const displayName = vendorName.charAt(0).toUpperCase() + vendorName.slice(1);
          const result = await database.run('INSERT INTO vendors (name, display_name) VALUES (?, ?)', vendorName, displayName);
          return result.lastID;
        }
        return vendor.id;
      }
    }
    return null;
  }
}

module.exports = VendorNormalizationService;

--- FILE: ./server/services/financialMonthService.js ---
const AppSettings = require('../models/AppSettings');
const { getPreviousWorkday, getHolidays } = require('./dateHelpers');

class FinancialMonthService {
  constructor(settings, holidays) {
    this.fiscalDayStart = settings.fiscal_day_start;
    this.holidays = holidays;
  }

  getFinancialMonthRange(year, month) {
    const targetStartDate = new Date(year, month - 1, this.fiscalDayStart);
    targetStartDate.setMonth(targetStartDate.getMonth() - 1);
    const fiscalMonthStartDate = getPreviousWorkday(targetStartDate, this.holidays);

    const targetEndDate = new Date(year, month - 1, this.fiscalDayStart);
    const nextFiscalMonthStartDate = getPreviousWorkday(targetEndDate, this.holidays);
    
    const fiscalMonthEndDate = new Date(nextFiscalMonthStartDate);
    fiscalMonthEndDate.setDate(fiscalMonthEndDate.getDate() - 1);

    return {
      startDate: fiscalMonthStartDate.toISOString().split('T')[0],
      endDate: fiscalMonthEndDate.toISOString().split('T')[0],
    };
  }

  getCurrentFinancialMonth() {
    const today = new Date();
    let year = today.getFullYear();
    let month = today.getMonth() + 1; // getMonth() is 0-indexed

    if (today.getDate() >= this.fiscalDayStart) {
      month += 1;
      if (month > 12) {
        month = 1;
        year += 1;
      }
    }
    
    const range = this.getFinancialMonthRange(year, month);

    return {
      year,
      month,
      startDate: range.startDate,
      endDate: range.endDate,
    };
  }
}

async function createFinancialMonthService() {
  const [settings, holidays] = await Promise.all([
    AppSettings.get(),
    getHolidays()
  ]);
  // Return null if settings are not yet configured, instead of throwing an error.
  if (!settings || !settings.fiscal_day_start) { 
    return null;
  }
  return new FinancialMonthService(settings, holidays);
}

module.exports = { createFinancialMonthService };
--- FILE: ./server/services/forecastService.js ---
const RecurringBill = require('../models/RecurringBill');
const PlannedIncome = require('../models/PlannedIncome');
const { getHolidays, getPreviousWorkday } = require('./dateHelpers');

class ForecastService {
  static async generateForecast() {
    let currentBalance = 0;
    const forecastDays = [];
    const today = new Date();
    const forecastEndDate = new Date();
    forecastEndDate.setMonth(forecastEndDate.getMonth() + 12);

    const [activeBills, activeIncomes, holidays] = await Promise.all([
        RecurringBill.findAllActive(),
        PlannedIncome.findAllActive(),
        getHolidays()
    ]);

    for (let d = new Date(today); d <= forecastEndDate; d.setDate(d.getDate() + 1)) {
      const currentDate = new Date(d);
      const isoDate = currentDate.toISOString().split('T')[0];
      let dailyOutflow = 0;
      let dailyInflow = 0;
      const todaysBills = [];
      const todaysIncomes = [];

      for (const bill of activeBills) {
        let paymentDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), bill.day_of_month);
        if (paymentDate.getMonth() === currentDate.getMonth()) {
          let adjustedDate = getPreviousWorkday(paymentDate, holidays);
          if (adjustedDate.toISOString().split('T')[0] === isoDate) {
            dailyOutflow += bill.amount;
            todaysBills.push({ name: bill.vendor_name, amount: bill.amount });
          }
        }
      }

      for (const income of activeIncomes) {
          let incomeDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), income.day_of_month);
           if (incomeDate.getMonth() === currentDate.getMonth()) {
              let adjustedDate = getPreviousWorkday(incomeDate, holidays);
               if (adjustedDate.toISOString().split('T')[0] === isoDate) {
                   dailyInflow += income.amount;
                   todaysIncomes.push({ name: income.source_name, amount: income.amount });
               }
           }
      }

      currentBalance += dailyInflow;
      currentBalance -= dailyOutflow;

      forecastDays.push({
        date: isoDate,
        inflows: todaysIncomes,
        outflows: todaysBills,
        total_inflow: dailyInflow,
        total_outflow: dailyOutflow,
        running_balance: Math.round(currentBalance * 100) / 100
      });
    }

    return forecastDays;
  }
}

module.exports = ForecastService;
--- FILE: ./server/services/holidayService.js ---
const db = require('../config/database');

class HolidayService {
  static async fetchAndStoreHolidays(jurisdiction) {
    try {
      const response = await fetch('https://www.gov.uk/bank-holidays.json');
      if (!response.ok) {
        throw new Error(`Failed to fetch holiday data: ${response.statusText}`);
      }
      const allHolidays = await response.json();
      const regionHolidays = allHolidays[jurisdiction];

      if (!regionHolidays || !regionHolidays.events) {
        throw new Error(`No holiday data found for jurisdiction: ${jurisdiction}`);
      }

      const database = await db.openDb();
      await database.exec('BEGIN TRANSACTION');

      await database.run('DELETE FROM public_holidays');

      const sql = `INSERT OR IGNORE INTO public_holidays (holiday_date, name) VALUES (?, ?)`;
      const stmt = await database.prepare(sql);

      for (const event of regionHolidays.events) {
        await stmt.run(event.date, event.title);
      }

      await stmt.finalize();
      await database.exec('COMMIT');
      console.log(`Successfully stored ${regionHolidays.events.length} holidays for ${jurisdiction}.`);

    } catch (error) {
      console.error('Error in fetchAndStoreHolidays:', error);
    }
  }
}

module.exports = HolidayService;

--- FILE: ./server/services/csvParserService.js ---
const { parse } = require('csv-parse/sync');
const ImportProfile = require('../models/ImportProfile');

function cleanAndParseFloat(value) {
    if (typeof value !== 'string') return 0;
    // This regex is more robust, handling commas in thousands and currency symbols.
    const cleanedValue = value.replace(/[^0-9.-]+/g, "");
    return parseFloat(cleanedValue || 0);
}

function normalizeDate(dateString, format) {
    if (!dateString) return null;
    
    // Attempt standard parsing first
    let date = new Date(dateString);
    if (!isNaN(date.getTime())) {
        return date.toISOString().split('T')[0];
    }

    // Use format if provided (e.g., DD/MM/YYYY)
    if (format) {
        const separator = format.match(/[^A-Z]/)[0];
        const formatParts = format.toUpperCase().split(separator);
        const dateParts = dateString.split(separator);
        
        if (formatParts.length === dateParts.length) {
            const dateObj = {};
            formatParts.forEach((part, i) => {
                dateObj[part] = parseInt(dateParts[i], 10);
            });

            const year = dateObj.YYYY || dateObj.YY;
            const month = dateObj.MM - 1; // Month is 0-indexed
            const day = dateObj.DD;

            if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
                date = new Date(Date.UTC(year, month, day));
                 if (!isNaN(date.getTime())) {
                    return date.toISOString().split('T')[0];
                }
            }
        }
    }
    
    return null; // Return null if all parsing fails
}


class CsvParserService {
  static async parse(fileBuffer, profileId) {
    const profile = await ImportProfile.findById(profileId);
    if (!profile) {
      throw new Error('Import profile not found.');
    }

    const records = parse(fileBuffer, {
      columns: header => header.map(h => h.trim()),
      skip_empty_lines: true,
      trim: true,
    });

    const results = [];

    for (const row of records) {
      const date = normalizeDate(row[profile.date_col], profile.date_format);
      if (!date) continue; // Skip rows with invalid dates

      const description = row[profile.description_col] || 'N/A';
      let amount = 0;

      if (profile.amount_col && row[profile.amount_col]) {
        amount = cleanAndParseFloat(row[profile.amount_col]);
      } else if (profile.debit_col && profile.credit_col) {
        const debit = cleanAndParseFloat(row[profile.debit_col]);
        const credit = cleanAndParseFloat(row[profile.credit_col]);
        amount = credit - debit;
      }
      
      if (amount === 0) continue; // Skip zero-amount transactions

      results.push({
        date: date,
        description: description,
        amount: amount, // Positive for income, negative for expenses
        source: profile.profile_name,
      });
    }

    return results;
  }
}

module.exports = CsvParserService;
--- FILE: ./clean_build.sh ---
#!/bin/bash

# =================================================================
#  "Nuclear Option" Clean Build Script
# =================================================================
#  This script will completely destroy and rebuild the application,
#  ensuring a clean slate and no caching issues.
# =================================================================

echo "--- STEP 1: Stopping application and deleting all data (including the database)..."
docker compose down -v

echo "--- STEP 2: Destroying all unused Docker images..."
docker image prune -a -f

echo "--- STEP 3: Destroying the Docker build cache..."
docker builder prune -f

echo "--- STEP 4: Performing final fresh build and starting application..."
docker compose up --build -d

echo ""
echo "--- CLEAN BUILD COMPLETE ---"
echo "Application is starting. You will need to perform the initial setup again."

--- FILE: ./deployment/Dockerfile.server ---
# =================================================================
#  Dockerfile for the Node.js Backend Server
# =================================================================

# Use an official Node.js runtime as a parent image.
FROM node:20-bookworm

# Set the working directory inside the container
WORKDIR /usr/src/app

# Copy package.json and package-lock.json
COPY server/package*.json ./

# Install application dependencies
# This is run as root to ensure global packages can be installed if needed
RUN npm install

# Copy the rest of the application source code
COPY ./server .

# Create the data directory and change ownership to the 'node' user.
# This is the critical fix that allows the app to write/restore the database.
RUN mkdir -p data/sqlite && chown -R node:node /usr/src/app

# Switch to the non-root 'node' user for better security
USER node

# Make port 8080 available
EXPOSE 8080

# Define the command to run the app
CMD [ "node", "server.js" ]
--- FILE: ./deployment/Dockerfile.client ---
# =================================================================
#  Dockerfile for the React Client (with Nginx Proxy)
# =================================================================
#  This Dockerfile has two stages:
#  1. Build Stage: Compiles the React app into static HTML/JS/CSS.
#  2. Production Stage: Copies the built files AND our custom
#     nginx config into a lightweight nginx server.
# =================================================================

# --- Build Stage ---
FROM node:20-bookworm as build

WORKDIR /app

COPY client/package.json ./

RUN npm install

COPY client/ ./

# Finally, build the application.
RUN npm run build

# --- Production Stage ---
FROM nginx:stable-alpine

# Copy our custom nginx configuration file
COPY deployment/nginx.conf /etc/nginx/conf.d/default.conf

# Copy the built static files from the 'build' stage
COPY --from=build /app/build /usr/share/nginx/html

# When the container starts, nginx will automatically serve the files.
EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]

--- FILE: ./deployment/nginx.conf ---
# =================================================================
#  Nginx Configuration
# =================================================================
#  This configuration file acts as a reverse proxy. It serves the
#  static React frontend and forwards all API requests to the
#  backend server.
# =================================================================

server {
    # Listen on port 80, the standard HTTP port
    listen 80;

    # Serve the React application files
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
        # This is important for single-page applications like React.
        # It ensures that if you refresh a page like /dashboard,
        # nginx still serves the main index.html file.
        try_files $uri /index.html;
    }

    # Forward API requests to the backend server
    location /api {
        # 'server' is the name of our backend service in docker-compose.yml
        proxy_pass http://server:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}

--- FILE: ./docker-compose.yml ---
# =================================================================
#  Docker Compose for Family Budget Management Tool (Corrected)
# =================================================================

# Define a network for our containers to communicate on
networks:
  budget-net:
    driver: bridge

services:
  # 1. The Backend Node.js/Express API Server
  server:
    build:
      context: .
      dockerfile: ./deployment/Dockerfile.server
    container_name: budget_app_server
    restart: unless-stopped
    volumes:
      - budget_db_data:/usr/src/app/data/sqlite
    # Connect the server to our custom network
    networks:
      - budget-net
    environment:
      - NODE_ENV=production

  # 2. The Frontend Service (React App + Nginx Proxy)
  client:
    build:
      context: .
      dockerfile: ./deployment/Dockerfile.client
    container_name: budget_app_client
    ports:
      # Expose the application on port 80 of your Mac
      - "80:80"
    restart: unless-stopped
    # The client depends on the server being started
    depends_on:
      - server
    # Connect the client to the same custom network
    networks:
      - budget-net

volumes:
  budget_db_data: {}
--- FILE: ./client/tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{js,jsx}',
    './components/**/*.{js,jsx}',
    './app/**/*.{js,jsx}',
    './src/**/*.{js,jsx}',
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}

--- FILE: ./client/Dockerfile ---
FROM node:lts-alpine
ENV NODE_ENV=production
WORKDIR /usr/src/app
COPY ["package.json", "package-lock.json*", "npm-shrinkwrap.json*", "./"]
RUN npm install --production --silent && mv node_modules ../
COPY . .
EXPOSE 8080
RUN chown -R node /usr/src/app
USER node
CMD ["npm", "start"]

--- FILE: ./client/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Family Budget Management Tool"
    />
    <title>Family Budget</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

--- FILE: ./client/package.json ---
{
  "name": "client",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@radix-ui/react-accordion": "^1.1.2",
    "@radix-ui/react-alert-dialog": "^1.0.5",
    "@radix-ui/react-checkbox": "^1.0.4",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-select": "^2.0.0",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-tabs": "^1.0.4",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "lucide-react": "^0.400.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.24.1",
    "react-scripts": "5.0.1",
    "recharts": "^2.12.7",
    "tailwind-merge": "^2.3.0",
    "tailwindcss-animate": "^1.0.7"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "tailwindcss": "^3.4.4"
  }
}
--- FILE: ./client/postcss.config.js ---
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

--- FILE: ./client/src/contexts/AuthContext.js ---
import React, { createContext, useState, useContext, useCallback, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import * as api from '../services/api';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [token, setToken] = useState(() => localStorage.getItem('authToken'));
  const [appSettings, setAppSettings] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [initError, setInitError] = useState(null);
  const navigate = useNavigate();

  const initializeApp = useCallback(async () => {
    setIsLoading(true);
    setInitError(null);
    try {
      const settings = await api.getAppSettings();
      setAppSettings(settings);
    } catch (error) {
      console.error("Initialization Error:", error);
      setInitError(error.message || 'Failed to connect to the server. Please ensure it is running and try again.');
      setAppSettings(null);
      setToken(null);
      localStorage.removeItem('authToken');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    initializeApp();
  }, [initializeApp]);

  const login = async (email, password) => {
    const data = await api.login(email, password);
    if (data && data.token) {
      localStorage.setItem('authToken', data.token);
      setToken(data.token);
      await initializeApp(); // Re-fetch settings after a successful login
    } else {
      throw new Error('Login failed. Please check your credentials.');
    }
  };

  const logout = () => {
    setToken(null);
    localStorage.removeItem('authToken');
    setAppSettings(null);
    navigate('/login');
  };

  const value = {
    token,
    login,
    logout,
    isAuthenticated: !!token,
    appSettings,
    isLoading,
    initError,
    initializeApp
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  return useContext(AuthContext);
}
--- FILE: ./client/src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import { AuthProvider } from './contexts/AuthContext';
import { BrowserRouter } from 'react-router-dom';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <BrowserRouter>
      <AuthProvider>
        <App />
      </AuthProvider>
    </BrowserRouter>
  </React.StrictMode>
);

--- FILE: ./client/src/index.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

--- FILE: ./client/src/components/CategorizationModal.js ---
import React, { useState, useEffect } from 'react';
import * as api from '../services/api';
import { Button } from './ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from './ui/dialog';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';

function CategorizationModal({ transaction, allSubcategories, allVendors, onClose, onSave }) {
  const [selectedSubcategory, setSelectedSubcategory] = useState('');
  const [selectedVendor, setSelectedVendor] = useState('');
  const [newVendorName, setNewVendorName] = useState('');
  const [transactionType, setTransactionType] = useState('expense');
  const isOpen = !!transaction;

  useEffect(() => {
    if (transaction) {
      setSelectedSubcategory(transaction.subcategory_id?.toString() || '');
      setSelectedVendor(transaction.vendor_id?.toString() || '');
      setTransactionType(transaction.transaction_type || (transaction.is_debit ? 'expense' : 'income'));
      setNewVendorName('');
    }
  }, [transaction]);

  const handleSave = async () => {
    try {
      let vendorIdToSave = selectedVendor;
      if (selectedVendor === 'new' && newVendorName) {
        const newVendor = await api.createVendor({ name: newVendorName.toLowerCase(), displayName: newVendorName });
        vendorIdToSave = newVendor.id.toString();
      }

      if (vendorIdToSave && vendorIdToSave !== transaction.vendor_id?.toString()) {
        await api.updateTransactionVendor(transaction.id, vendorIdToSave);
      }
      
      const payload = {
          subcategory_id: selectedSubcategory || null,
          transaction_type: transactionType
      };
      await api.categorizeTransaction(transaction.id, payload);

      await onSave();
      onClose();
    } catch (error) {
      console.error("Failed to save categorization", error);
      alert("Error: " + error.message);
    }
  };

  const formatCurrency = (value) => new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(value || 0);

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[525px]">
        <DialogHeader><DialogTitle>Categorize Transaction</DialogTitle></DialogHeader>
        {transaction && (
          <div className="py-4 space-y-4">
            <div className="bg-muted p-3 rounded-md text-sm">
              <div className="flex justify-between"><span>Date:</span> <strong>{new Date(transaction.transaction_date).toLocaleDateString("en-GB")}</strong></div>
              <div className="flex justify-between"><span>Description:</span> <strong>{transaction.description_original}</strong></div>
              <div className="flex justify-between"><span>Amount:</span> <strong className={transaction.is_debit ? 'text-destructive' : 'text-green-600'}>{formatCurrency(transaction.amount)}</strong></div>
            </div>
            {!transaction.is_debit && (
              <div className="grid gap-2">
                <Label>Transaction Type</Label>
                <Select value={transactionType} onValueChange={setTransactionType}>
                    <SelectTrigger><SelectValue /></SelectTrigger>
                    <SelectContent>
                        <SelectItem value="income">Income</SelectItem>
                        <SelectItem value="refund">Refund</SelectItem>
                    </SelectContent>
                </Select>
              </div>
            )}
            <div className="grid gap-2">
              <Label>Vendor</Label>
              <Select onValueChange={setSelectedVendor} value={selectedVendor}><SelectTrigger><SelectValue placeholder="-- Select Vendor --" /></SelectTrigger><SelectContent>{allVendors.map(v => <SelectItem key={v.id} value={v.id.toString()}>{v.display_name}</SelectItem>)}<SelectItem value="new">-- Create New Vendor --</SelectItem></SelectContent></Select>
              {selectedVendor === 'new' && ( <Input placeholder="New Vendor Name" value={newVendorName} onChange={(e) => setNewVendorName(e.target.value)} className="mt-2" /> )}
            </div>
            <div className="grid gap-2">
              <Label>Category</Label>
               <Select onValueChange={setSelectedSubcategory} value={selectedSubcategory}><SelectTrigger><SelectValue placeholder="-- Select Category --" /></SelectTrigger><SelectContent>{allSubcategories.map(s => <SelectItem key={s.id} value={s.id.toString()}>{s.category_name} &gt; {s.name}</SelectItem>)}</SelectContent></Select>
            </div>
          </div>
        )}
        <DialogFooter><Button variant="outline" onClick={onClose}>Cancel</Button><Button onClick={handleSave}>Save Changes</Button></DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
export default CategorizationModal;
--- FILE: ./client/src/components/ui/dialog.jsx ---
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "../../lib/utils"

const Dialog = DialogPrimitive.Root
const DialogTrigger = DialogPrimitive.Trigger
const DialogPortal = DialogPrimitive.Portal
const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props} />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}>
      {children}
      <DialogPrimitive.Close
        className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-accent-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}) => (
  <div
    className={cn("flex flex-col space-y-1.5 text-center sm:text-left", className)}
    {...props} />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}) => (
  <div
    className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)}
    {...props} />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props} />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props} />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

--- FILE: ./client/src/components/ui/input.jsx ---
import * as React from "react"

import { cn } from "../../lib/utils"

const Input = React.forwardRef(({ className, type, ...props }, ref) => {
  return (
    <input
      type={type}
      className={cn(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      ref={ref}
      {...props} />
  )
})
Input.displayName = "Input"

export { Input }

--- FILE: ./client/src/components/ui/select.jsx ---
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "../../lib/utils"

const Select = SelectPrimitive.Root
const SelectGroup = SelectPrimitive.Group
const SelectValue = SelectPrimitive.Value
const SelectTrigger = React.forwardRef(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}>
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}>
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}>
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}>
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn("p-1", position === "popper" &&
          "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]")}>
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props} />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}>
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props} />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

--- FILE: ./client/src/components/ui/dropdown-menu.jsx ---
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"
import { cn } from "../../lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root
const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger
const DropdownMenuGroup = DropdownMenuPrimitive.Group
const DropdownMenuPortal = DropdownMenuPrimitive.Portal
const DropdownMenuSub = DropdownMenuPrimitive.Sub
const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn("flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent", inset && "pl-8", className)}
    {...props}>
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn("z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", className)}
    {...props} />
))
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn("z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", className)}
      {...props} />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn("relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", inset && "pl-8", className)}
    {...props} />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn("relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", className)}
    checked={checked}
    {...props}>
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn("relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", className)}
    {...props}>
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label ref={ref} className={cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)} {...props} />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-muted", className)} {...props} />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({ className, ...props }) => {
  return (<span className={cn("ml-auto text-xs tracking-widest opacity-60", className)} {...props} />)
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem, DropdownMenuCheckboxItem, DropdownMenuRadioItem, DropdownMenuLabel, DropdownMenuSeparator, DropdownMenuShortcut, DropdownMenuGroup, DropdownMenuPortal, DropdownMenuSub, DropdownMenuSubContent, DropdownMenuSubTrigger, DropdownMenuRadioGroup }

--- FILE: ./client/src/components/ui/checkbox.jsx ---
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"
import { cn } from "../../lib/utils"

const Checkbox = React.forwardRef(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}>
    <CheckboxPrimitive.Indicator className={cn("flex items-center justify-center text-current")}>
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

--- FILE: ./client/src/components/ui/button.jsx ---
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva } from "class-variance-authority";

import { cn } from "../../lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Button = React.forwardRef(({ className, variant, size, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"
  return (
    <Comp
      className={cn(buttonVariants({ variant, size, className }))}
      ref={ref}
      {...props} />
  )
})
Button.displayName = "Button"

export { Button, buttonVariants }

--- FILE: ./client/src/components/ui/table.jsx ---
import * as React from "react"
import { cn } from "../../lib/utils"

const Table = React.forwardRef(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props} />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props} />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", className)}
    {...props} />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props} />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props} />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props} />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props} />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

--- FILE: ./client/src/components/ui/card.jsx ---
import * as React from "react"

import { cn } from "../../lib/utils"

const Card = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("rounded-lg border bg-card text-card-foreground shadow-sm", className)}
    {...props} />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props} />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef(({ className, children, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn("text-2xl font-semibold leading-none tracking-tight", className)}
    {...props}
  >
    {children}
  </h3>
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props} />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props} />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

--- FILE: ./client/src/components/ui/tabs.jsx ---
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"
import { cn } from "../../lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props} />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props} />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props} />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

--- FILE: ./client/src/components/ui/alert-dialog.jsx ---
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"
import { cn } from "../../lib/utils"
import { buttonVariants } from "./button"

const AlertDialog = AlertDialogPrimitive.Root
const AlertDialogTrigger = AlertDialogPrimitive.Trigger
const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn("fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", className)}
    {...props}
    ref={ref} />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg", className)}
      {...props} />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({ className, ...props }) => (
  <div className={cn("flex flex-col space-y-2 text-center sm:text-left", className)} {...props} />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({ className, ...props }) => (
  <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)} {...props} />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title ref={ref} className={cn("text-lg font-semibold", className)} {...props} />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
))
AlertDialogDescription.displayName = AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action ref={ref} className={cn(buttonVariants(), className)} {...props} />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel ref={ref} className={cn(buttonVariants({ variant: "outline" }), "mt-2 sm:mt-0", className)} {...props} />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export { AlertDialog, AlertDialogPortal, AlertDialogOverlay, AlertDialogTrigger, AlertDialogContent, AlertDialogHeader, AlertDialogFooter, AlertDialogTitle, AlertDialogDescription, AlertDialogAction, AlertDialogCancel }

--- FILE: ./client/src/components/ui/accordion.jsx ---
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"
import { cn } from "../../lib/utils"

const Accordion = AccordionPrimitive.Root
const AccordionItem = React.forwardRef(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item ref={ref} className={cn("border-b", className)} {...props} />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}>
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}>
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))
AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }

--- FILE: ./client/src/components/ui/label.jsx ---
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva } from "class-variance-authority";

import { cn } from "../../lib/utils"
const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props} />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

--- FILE: ./client/src/components/ui/sheet.jsx ---
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva } from "class-variance-authority";
import { X } from "lucide-react"

import { cn } from "../../lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref} />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

const SheetContent = React.forwardRef(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content ref={ref} className={cn(sheetVariants({ side }), className)} {...props}>
      {children}
      <SheetPrimitive.Close
        className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}) => (
  <div
    className={cn("flex flex-col space-y-2 text-center sm:text-left", className)}
    {...props} />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}) => (
  <div
    className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)}
    {...props} />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props} />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props} />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

--- FILE: ./client/src/components/settings/PlannedIncomeManager.jsx ---
import React, { useState, useEffect } from 'react';
import * as api from '../../services/api';
import { Button } from '../ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogClose } from '../ui/dialog';
import { Input } from '../ui/input';
import { Label } from '../ui/label';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '../ui/table';
import { MoreHorizontal, PlusCircle } from 'lucide-react';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '../ui/dropdown-menu';

function PlannedIncomeManager() {
    const [incomes, setIncomes] = useState([]);
    const [loading, setLoading] = useState(true);
    const [isDialogOpen, setIsDialogOpen] = useState(false);
    const [editingIncome, setEditingIncome] = useState(null);

    const fetchIncomes = () => {
        api.getActivePlannedIncome().then(setIncomes).finally(() => setLoading(false));
    };

    useEffect(() => {
        fetchIncomes();
    }, []);

    const handleSave = async (e) => {
        e.preventDefault();
        const formData = new FormData(e.target);
        const data = Object.fromEntries(formData.entries());
        try {
            if (editingIncome) {
                await api.updatePlannedIncome(editingIncome.id, data);
            } else {
                await api.createPlannedIncome(data);
            }
            fetchIncomes();
            setIsDialogOpen(false);
            setEditingIncome(null);
        } catch (err) {
            alert(`Error: ${err.message}`);
        }
    };

    const handleDeactivate = async (id) => {
        if (window.confirm('Are you sure you want to deactivate this income source?')) {
            await api.deactivatePlannedIncome(id);
            fetchIncomes();
        }
    };

    const formatCurrency = (value) => new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(value || 0);

    if(loading) return <p>Loading...</p>

    return (
        <div className="space-y-4">
            <div className="flex justify-end">
                <Button onClick={() => { setEditingIncome(null); setIsDialogOpen(true); }}><PlusCircle className="h-4 w-4 mr-2"/>Add Income Source</Button>
            </div>
             <div className="rounded-md border">
                <Table>
                    <TableHeader><TableRow><TableHead>Source</TableHead><TableHead>Amount</TableHead><TableHead>Day of Month</TableHead><TableHead className="text-right">Actions</TableHead></TableRow></TableHeader>
                    <TableBody>
                        {incomes.map(income => (
                            <TableRow key={income.id}>
                                <TableCell className="font-medium">{income.source_name}</TableCell>
                                <TableCell>{formatCurrency(income.amount)}</TableCell>
                                <TableCell>{income.day_of_month}</TableCell>
                                <TableCell className="text-right">
                                    <DropdownMenu>
                                        <DropdownMenuTrigger asChild><Button variant="ghost" className="h-8 w-8 p-0"><MoreHorizontal className="h-4 w-4" /></Button></DropdownMenuTrigger>
                                        <DropdownMenuContent align="end">
                                            <DropdownMenuItem onClick={() => { setEditingIncome(income); setIsDialogOpen(true); }}>Edit</DropdownMenuItem>
                                            <DropdownMenuItem className="text-red-600" onClick={() => handleDeactivate(income.id)}>Deactivate</DropdownMenuItem>
                                        </DropdownMenuContent>
                                    </DropdownMenu>
                                </TableCell>
                            </TableRow>
                        ))}
                    </TableBody>
                </Table>
            </div>

            <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
                <DialogContent>
                    <DialogHeader><DialogTitle>{editingIncome ? 'Edit' : 'Add'} Planned Income</DialogTitle></DialogHeader>
                    <form onSubmit={handleSave} className="space-y-4 py-4">
                        <div><Label>Source Name</Label><Input name="source_name" defaultValue={editingIncome?.source_name} required /></div>
                        <div><Label>Amount ()</Label><Input name="amount" type="number" step="0.01" defaultValue={editingIncome?.amount} required /></div>
                        <div><Label>Day of Month</Label><Input name="day_of_month" type="number" min="1" max="31" defaultValue={editingIncome?.day_of_month} required /></div>
                        <DialogFooter>
                            <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
                            <Button type="submit">Save</Button>
                        </DialogFooter>
                    </form>
                </DialogContent>
            </Dialog>
        </div>
    )
}
export default PlannedIncomeManager;
--- FILE: ./client/src/components/settings/RecurringBillsManager.jsx ---
import React, { useState, useEffect, useCallback } from 'react';
import * as api from '../../services/api';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '../ui/table';
import { Input } from '../ui/input';
import { Button, buttonVariants } from '../ui/button';
import { MoreHorizontal, PlusCircle } from 'lucide-react';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuLabel, DropdownMenuTrigger } from '../ui/dropdown-menu';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogClose } from '../ui/dialog';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from '../ui/alert-dialog';
import { Label } from '../ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../ui/select';
import { Checkbox } from '../ui/checkbox';

// This component can be used as a full-page manager or as a modal for creating a bill from a transaction
function RecurringBillsManager({ isOpen: externalIsOpen, onClose: externalOnClose, billToCreateFromTx = null, onSave: externalOnSave}) {
  const [bills, setBills] = useState([]);
  const [vendors, setVendors] = useState([]);
  const [subcategories, setSubcategories] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  
  // Internal state for managing the dialog
  const [isInternalDialogOpen, setInternalDialogOpen] = useState(false);
  
  const [editingBill, setEditingBill] = useState(null);
  
  const getInitialFormData = () => ({
    vendor_id: '',
    subcategory_id: '',
    amount: '',
    day_of_month: '',
    start_date: new Date().toISOString().split('T')[0],
    end_date: '',
    notes: '',
  });

  const [formData, setFormData] = useState(getInitialFormData());

  const isControlled = externalIsOpen !== undefined;
  const isOpen = isControlled ? externalIsOpen : isInternalDialogOpen;

  const handleCloseDialog = () => {
    setEditingBill(null);
    setFormData(getInitialFormData()); 
    if (isControlled) {
      externalOnClose();
    } else {
      setInternalDialogOpen(false);
    }
  };
  
  const fetchPageData = useCallback(() => {
    setLoading(true);
    Promise.all([
      api.getActiveRecurringBills(),
      api.getAllVendors(),
      api.getAllSubcategories()
    ]).then(([billsData, vendorsData, subcategoriesData]) => {
      setBills(billsData);
      setVendors(vendorsData);
      setSubcategories(subcategoriesData);
      setError('');
    }).catch(err => {
      setError(err.message);
    }).finally(() => {
      setLoading(false);
    });
  }, []);

  useEffect(() => {
    // Only fetch the full list of bills if we are in standalone mode.
    if (!isControlled) {
      fetchPageData();
    } else {
        // In modal mode, we still need vendors and subcategories for the form dropdowns
        setLoading(true);
         Promise.all([
          api.getAllVendors(),
          api.getAllSubcategories()
        ]).then(([vendorsData, subcategoriesData]) => {
            setVendors(vendorsData);
            setSubcategories(subcategoriesData);
            setLoading(false);
        }).catch(err => {
          setError(err.message);
          setLoading(false);
        });
    }
  }, [isControlled, fetchPageData]);
  
  // Effect to handle opening the dialog and pre-filling form data from either an existing bill or a transaction
  useEffect(() => {
    if (isOpen) {
        if (billToCreateFromTx) {
            setEditingBill(null);
            setFormData({
                vendor_id: billToCreateFromTx.vendor_id?.toString() || '',
                subcategory_id: billToCreateFromTx.subcategory_id?.toString() || '',
                amount: billToCreateFromTx.amount || '',
                day_of_month: new Date(billToCreateFromTx.transaction_date).getUTCDate(), // Use UTC date to avoid timezone issues
                start_date: new Date().toISOString().split('T')[0],
                end_date: '',
                notes: `From transaction: ${billToCreateFromTx.description_original}`,
            });
        } else if (editingBill) {
            setFormData({
                vendor_id: editingBill.vendor_id?.toString() || '',
                subcategory_id: editingBill.subcategory_id?.toString() || '',
                amount: editingBill.amount || '',
                day_of_month: editingBill.day_of_month || '',
                start_date: editingBill.start_date ? new Date(editingBill.start_date).toISOString().split('T')[0] : '',
                end_date: editingBill.end_date ? new Date(editingBill.end_date).toISOString().split('T')[0] : '',
                notes: editingBill.notes || '',
            });
        } else {
            setEditingBill(null);
            setFormData(getInitialFormData());
        }
    }
  }, [isOpen, editingBill, billToCreateFromTx]);

  const handleOpenDialog = (bill = null) => {
    setEditingBill(bill);
    setInternalDialogOpen(true);
  };
  
  const handleFormChange = (e) => setFormData(prev => ({ ...prev, [e.target.name]: e.target.value }));
  const handleSelectChange = (name, value) => setFormData(prev => ({ ...prev, [name]: value }));
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    const payload = { ...formData, end_date: formData.end_date || null };
    try {
      if (editingBill) {
        await api.updateRecurringBill(editingBill.id, payload);
      } else {
        await api.createRecurringBill(payload);
      }
      
      if (isControlled && externalOnSave) {
        externalOnSave();
      } else {
        fetchPageData();
      }
      handleCloseDialog();
    } catch (err) { alert(`Error: ${err.message}`); }
  };

  const handleDeactivate = async (billId) => {
    try {
      await api.deactivateRecurringBill(billId);
      fetchPageData();
    } catch (err) { alert(`Error: ${err.message}`); }
  };

  const formatCurrency = (value) => new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(value || 0);

  const dialogComponent = (
        <Dialog open={isOpen} onOpenChange={handleCloseDialog}>
            <DialogContent>
                <DialogHeader><DialogTitle>{editingBill ? 'Edit' : 'Add'} Recurring Bill</DialogTitle></DialogHeader>
                <form onSubmit={handleSubmit} className="space-y-4 py-4">
                    <div className="grid gap-2"><Label>Vendor</Label><Select name="vendor_id" onValueChange={(v) => handleSelectChange('vendor_id',v)} value={formData.vendor_id} required><SelectTrigger><SelectValue placeholder="Select a vendor" /></SelectTrigger><SelectContent>{vendors.map(v => <SelectItem key={v.id} value={v.id.toString()}>{v.display_name}</SelectItem>)}</SelectContent></Select></div>
                    <div className="grid gap-2"><Label>Category</Label><Select name="subcategory_id" onValueChange={(v) => handleSelectChange('subcategory_id',v)} value={formData.subcategory_id} required><SelectTrigger><SelectValue placeholder="Select a category" /></SelectTrigger><SelectContent>{subcategories.map(s => <SelectItem key={s.id} value={s.id.toString()}>{s.category_name} &gt; {s.name}</SelectItem>)}</SelectContent></Select></div>
                    <div className="grid grid-cols-2 gap-4">
                        <div className="grid gap-2"><Label htmlFor="amount">Amount ()</Label><Input id="amount" name="amount" type="number" step="0.01" value={formData.amount || ''} onChange={handleFormChange} required /></div>
                        <div className="grid gap-2"><Label htmlFor="day_of_month">Day of Month</Label><Input id="day_of_month" name="day_of_month" type="number" min="1" max="31" value={formData.day_of_month || ''} onChange={handleFormChange} required /></div>
                    </div>
                    <div className="grid grid-cols-2 gap-4">
                      <div className="grid gap-2"><Label htmlFor="start_date">Start Date</Label><Input id="start_date" name="start_date" type="date" value={formData.start_date || ''} onChange={handleFormChange} required /></div>
                      <div className="grid gap-2"><Label htmlFor="end_date">End Date (optional)</Label><Input id="end_date" name="end_date" type="date" value={formData.end_date || ''} onChange={handleFormChange} /></div>
                    </div>
                    <div className="grid gap-2"><Label htmlFor="notes">Notes</Label><Input id="notes" name="notes" value={formData.notes || ''} onChange={handleFormChange} /></div>
                    <DialogFooter><DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose><Button type="submit">{editingBill ? 'Update Bill' : 'Save Bill'}</Button></DialogFooter>
                </form>
            </DialogContent>
        </Dialog>
  );
  
  if (isControlled) {
      return dialogComponent;
  }
  
  if (loading && !isControlled) return <p>Loading recurring bills...</p>;
  if (error && !isControlled) return <p className="text-red-500">Error: {error}</p>;

  return (
    <div className="space-y-4">
        {dialogComponent}
        <div className="flex justify-end items-center"><Button onClick={() => handleOpenDialog()}><PlusCircle className="h-4 w-4 mr-2"/>Add Bill</Button></div>
        <div className="rounded-md border">
            <Table>
                <TableHeader><TableRow><TableHead>Vendor</TableHead><TableHead>Category</TableHead><TableHead>Amount</TableHead><TableHead>Day</TableHead><TableHead className="text-right">Actions</TableHead></TableRow></TableHeader>
                <TableBody>
                    {bills.length > 0 ? ( bills.map(bill => (<TableRow key={bill.id}><TableCell className="font-medium">{bill.vendor_name}</TableCell><TableCell className="text-muted-foreground">{bill.subcategory_name}</TableCell><TableCell>{formatCurrency(bill.amount)}</TableCell><TableCell>{bill.day_of_month}</TableCell><TableCell className="text-right"><AlertDialog><DropdownMenu><DropdownMenuTrigger asChild><Button variant="ghost" className="h-8 w-8 p-0"><MoreHorizontal className="h-4 w-4" /></Button></DropdownMenuTrigger><DropdownMenuContent align="end"><DropdownMenuLabel>Actions</DropdownMenuLabel><DropdownMenuItem onClick={() => handleOpenDialog(bill)}>Edit</DropdownMenuItem><AlertDialogTrigger asChild><DropdownMenuItem className="text-red-600">Deactivate</DropdownMenuItem></AlertDialogTrigger></DropdownMenuContent></DropdownMenu><AlertDialogContent><AlertDialogHeader><AlertDialogTitle>Are you sure?</AlertDialogTitle><AlertDialogDescription>This will deactivate the recurring bill. It will no longer be included in future cashflow forecasts.</AlertDialogDescription></AlertDialogHeader><AlertDialogFooter><AlertDialogCancel>Cancel</AlertDialogCancel><AlertDialogAction onClick={() => handleDeactivate(bill.id)} className={buttonVariants({ variant: "destructive" })}>Deactivate</AlertDialogAction></AlertDialogFooter></AlertDialogContent></AlertDialog></TableCell></TableRow>))) : ( <TableRow><TableCell colSpan="5" className="h-24 text-center">No active recurring bills found.</TableCell></TableRow> )}
                </TableBody>
            </Table>
        </div>
    </div>
  );
}

export default RecurringBillsManager;
--- FILE: ./client/src/components/settings/CategoryManager.jsx ---
import React, { useState, useEffect } from 'react';
import * as api from '../../services/api';
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '../ui/accordion';
import { Button, buttonVariants } from '../ui/button';
import { Input } from '../ui/input';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from '../ui/alert-dialog';
import { Trash2 } from 'lucide-react';

function CategoryManager() {
  const [categories, setCategories] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  const [newCategoryName, setNewCategoryName] = useState('');
  const [newSubcategoryNames, setNewSubcategoryNames] = useState({});

  const fetchCategories = () => {
    api.getCategoriesWithSubcategories()
      .then(data => setCategories(data))
      .catch(err => setError(err.message))
      .finally(() => setLoading(false));
  };

  useEffect(() => {
    fetchCategories();
  }, []);

  const handleCreateCategory = async (e) => {
    e.preventDefault();
    if (!newCategoryName.trim()) return;
    try {
      await api.createCategory(newCategoryName);
      setNewCategoryName('');
      fetchCategories();
    } catch (err) { alert(`Error: ${err.message}`); }
  };

  const handleCreateSubcategory = async (e, categoryId) => {
    e.preventDefault();
    const subcategoryName = newSubcategoryNames[categoryId];
    if (!subcategoryName || !subcategoryName.trim()) return;
    try {
      await api.createSubcategory(categoryId, subcategoryName);
      setNewSubcategoryNames(prev => ({ ...prev, [categoryId]: '' }));
      fetchCategories();
    } catch (err) { alert(`Error: ${err.message}`); }
  };

  const handleDeleteCategory = async (categoryId) => {
    try {
      await api.deleteCategory(categoryId);
      fetchCategories();
    } catch (err) { alert(`Error: ${err.message}`); }
  };

  const handleDeleteSubcategory = async (categoryId, subcategoryId) => {
    try {
      await api.deleteSubcategory(categoryId, subcategoryId);
      fetchCategories();
    } catch (err) { alert(`Error: ${err.message}`); }
  };

  const handleSubcategoryNameChange = (categoryId, value) => {
    setNewSubcategoryNames(prev => ({...prev, [categoryId]: value}));
  };

  if (loading) return <p>Loading categories...</p>;
  if (error) return <p className="text-red-500">Error: {error}</p>;

  return (
    <div className="space-y-6">
      <form onSubmit={handleCreateCategory} className="flex items-center gap-2 p-4 border rounded-lg">
        <Input
          placeholder="New Category Name"
          value={newCategoryName}
          onChange={(e) => setNewCategoryName(e.target.value)}
          className="flex-grow"
        />
        <Button type="submit">Add Category</Button>
      </form>

      <Accordion type="single" collapsible className="w-full">
        {categories.map(category => (
          <AccordionItem value={`category-${category.id}`} key={category.id}>
            <div className="flex items-center justify-between">
              <AccordionTrigger className="flex-grow">
                <span className="font-semibold">{category.name}</span>
              </AccordionTrigger>
              <AlertDialog>
                <AlertDialogTrigger asChild>
                   <Button variant="ghost" size="icon"><Trash2 className="h-4 w-4 text-red-500" /></Button>
                </AlertDialogTrigger>
                <AlertDialogContent>
                    <AlertDialogHeader><AlertDialogTitle>Delete "{category.name}"?</AlertDialogTitle><AlertDialogDescription>This will delete the main category and ALL its subcategories. This action cannot be undone.</AlertDialogDescription></AlertDialogHeader>
                    <AlertDialogFooter><AlertDialogCancel>Cancel</AlertDialogCancel><AlertDialogAction onClick={() => handleDeleteCategory(category.id)} className={buttonVariants({ variant: "destructive" })}>Delete</AlertDialogAction></AlertDialogFooter>
                </AlertDialogContent>
              </AlertDialog>
            </div>
            <AccordionContent>
              <div className="pl-4 space-y-4">
                <ul className="pl-6 space-y-2">
                  {category.subcategories && category.subcategories.length > 0 ? (
                    category.subcategories.map(sub => (
                      <li key={sub.id} className="flex items-center justify-between text-muted-foreground">
                        <span>- {sub.name}</span>
                        <AlertDialog>
                            <AlertDialogTrigger asChild>
                                <Button variant="ghost" size="icon"><Trash2 className="h-4 w-4 text-gray-400 hover:text-red-500" /></Button>
                            </AlertDialogTrigger>
                            <AlertDialogContent>
                                <AlertDialogHeader><AlertDialogTitle>Delete "{sub.name}"?</AlertDialogTitle><AlertDialogDescription>This action cannot be undone.</AlertDialogDescription></AlertDialogHeader>
                                <AlertDialogFooter><AlertDialogCancel>Cancel</AlertDialogCancel><AlertDialogAction onClick={() => handleDeleteSubcategory(category.id, sub.id)} className={buttonVariants({ variant: "destructive" })}>Delete</AlertDialogAction></AlertDialogFooter>
                            </AlertDialogContent>
                        </AlertDialog>
                      </li>
                    ))
                  ) : (
                    <p className="text-muted-foreground text-sm">No subcategories yet.</p>
                  )}
                </ul>
                <form onSubmit={(e) => handleCreateSubcategory(e, category.id)} className="flex items-center gap-2 pt-2 border-t">
                   <Input placeholder="New Subcategory Name" value={newSubcategoryNames[category.id] || ''} onChange={(e) => handleSubcategoryNameChange(category.id, e.target.value)} className="flex-grow"/>
                   <Button type="submit" variant="secondary">Add Subcategory</Button>
                </form>
              </div>
            </AccordionContent>
          </AccordionItem>
        ))}
      </Accordion>
    </div>
  );
}

export default CategoryManager;

--- FILE: ./client/src/components/settings/SavingsGoalModal.jsx ---
import React, { useState, useEffect } from 'react';
import * as api from '../../services/api';
import { Button } from '../ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogClose } from '../ui/dialog';
import { Input } from '../ui/input';
import { Label } from '../ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../ui/select';

function SavingsGoalModal({ isOpen, goal, accounts, onClose, onSave }) {

    const [formData, setFormData] = useState({});

    useEffect(() => {
        if (goal) {
            setFormData(goal);
        } else {
            setFormData({ priority: 'medium' });
        }
    }, [goal]);

    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({...prev, [name]: value}));
    };

    const handleSelectChange = (name, value) => {
        setFormData(prev => ({...prev, [name]: value}));
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            if (goal && goal.id) {
                await api.updateSavingsGoal(goal.id, formData);
            } else {
                await api.createSavingsGoal(formData);
            }
            onSave();
        } catch (err) {
            alert(`Error: ${err.message}`);
        }
    };

    return (
         <Dialog open={isOpen} onOpenChange={onClose}>
            <DialogContent>
              <DialogHeader><DialogTitle>{goal?.id ? 'Edit' : 'Add'} Savings Goal</DialogTitle></DialogHeader>
              <form onSubmit={handleSubmit} className="space-y-4 py-4">
                <div>
                    <Label htmlFor="account_id">Savings Account</Label>
                    <Select name="account_id" value={formData?.account_id?.toString()} onValueChange={(v) => handleSelectChange('account_id', v)} required>
                        <SelectTrigger><SelectValue placeholder="Select an account..."/></SelectTrigger>
                        <SelectContent>{accounts.map(acc => <SelectItem key={acc.id} value={acc.id.toString()}>{acc.name}</SelectItem>)}</SelectContent>
                    </Select>
                </div>
                <div><Label htmlFor="title">Goal Title</Label><Input id="title" name="title" value={formData?.title || ''} onChange={handleChange} required /></div>
                <div><Label htmlFor="target_amount">Target Amount ()</Label><Input id="target_amount" name="target_amount" type="number" step="0.01" value={formData?.target_amount || ''} onChange={handleChange} required /></div>
                <div><Label htmlFor="current_amount">Current Balance ()</Label><Input id="current_amount" name="current_amount" type="number" step="0.01" value={formData?.current_amount || '0.00'} onChange={handleChange} required /></div>
                <div><Label htmlFor="target_date">Target Date</Label><Input id="target_date" name="target_date" type="date" value={formData?.target_date ? new Date(formData.target_date).toISOString().split('T')[0] : ''} onChange={handleChange} /></div>
                <div>
                    <Label htmlFor="priority">Priority</Label>
                    <Select name="priority" value={formData?.priority || 'medium'} onValueChange={(v) => handleSelectChange('priority', v)}>
                        <SelectTrigger><SelectValue/></SelectTrigger>
                        <SelectContent>
                            <SelectItem value="high">High</SelectItem>
                            <SelectItem value="medium">Medium</SelectItem>
                            <SelectItem value="low">Low</SelectItem>
                        </SelectContent>
                    </Select>
                </div>
                <DialogFooter>
                  <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
                  <Button type="submit">Save Goal</Button>
                </DialogFooter>
              </form>
            </DialogContent>
          </Dialog>
    )
}
export default SavingsGoalModal;
--- FILE: ./client/src/components/settings/WithdrawalModal.jsx ---
import React, { useState, useEffect } from 'react';
import * as api from '../../services/api';
import { Button } from '../ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription, DialogClose } from '../ui/dialog';
import { Input } from '../ui/input';
import { Label } from '../ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../ui/select';

function WithdrawalModal({ goal, onSave, onClose }) {
  const [allSubcategories, setAllSubcategories] = useState([]);

  useEffect(() => {
    if (goal) {
      api.getAllSubcategories().then(setAllSubcategories);
    }
  }, [goal]);

  const handleSubmit = async (e) => {
    e.preventDefault();
    const formData = new FormData(e.target);
    const withdrawalData = Object.fromEntries(formData.entries());
    try {
      await api.withdrawFromSavingsGoal(goal.id, withdrawalData);
      onSave();
      onClose();
    } catch (error) {
      alert(`Error: ${error.message}`);
    }
  };

  if (!goal) return null;

  return (
    <Dialog open={!!goal} onOpenChange={onClose}>
        <DialogContent>
            <DialogHeader>
                <DialogTitle>Withdraw from "{goal.title}"</DialogTitle>
                <DialogDescription>
                    Transfer funds from your savings goal to a spending category. This will increase the budget for that category for the current month.
                </DialogDescription>
            </DialogHeader>
            <form onSubmit={handleSubmit} className="space-y-4 py-4">
                <div>
                    <Label htmlFor="amount">Amount to Withdraw ()</Label>
                    <Input id="amount" name="amount" type="number" step="0.01" required />
                </div>
                <div>
                    <Label htmlFor="subcategory_id">Spending Category</Label>
                    {/* CORRECTED: The field name is now subcategory_id */}
                    <Select name="subcategory_id" required>
                        <SelectTrigger>
                            <SelectValue placeholder="Select a category..." />
                        </SelectTrigger>
                        <SelectContent>
                            {allSubcategories.map(s => (
                                // CORRECTED: The > character is now properly escaped
                                <SelectItem key={s.id} value={s.id.toString()}>{s.category_name} &gt; {s.name}</SelectItem>
                            ))}
                        </SelectContent>
                    </Select>
                </div>
                <DialogFooter>
                    <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
                    <Button type="submit">Confirm Withdrawal</Button>
                </DialogFooter>
            </form>
        </DialogContent>
    </Dialog>
  );
}

export default WithdrawalModal;
--- FILE: ./client/src/components/settings/SavingsManager.jsx ---
import React, { useState, useEffect } from 'react';
import * as api from '../../services/api';
import { Button } from '../ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogClose } from '../ui/dialog';
import { Input } from '../ui/input';
import { Label } from '../ui/label';
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '../ui/accordion';
import { PlusCircle, Trash2, Edit } from 'lucide-react';
import SavingsGoalModal from './SavingsGoalModal';

function SavingsManager() {
  const [accounts, setAccounts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [isAccountDialogOpen, setIsAccountDialogOpen] = useState(false);
  const [isGoalDialogOpen, setIsGoalDialogOpen] = useState(false);
  const [editingAccount, setEditingAccount] = useState(null);
  const [editingGoal, setEditingGoal] = useState(null);

  const fetchAccounts = () => {
    api.getAllSavingsAccounts()
      .then(setAccounts)
      .catch(err => console.error(err))
      .finally(() => setLoading(false));
  };

  useEffect(() => {
    fetchAccounts();
  }, []);

  const handleSaveAccount = async (e) => {
    e.preventDefault();
    const formData = new FormData(e.target);
    const accountData = Object.fromEntries(formData.entries());
    try {
      if (editingAccount) {
        await api.updateSavingsAccount(editingAccount.id, accountData);
      } else {
        await api.createSavingsAccount(accountData);
      }
      fetchAccounts();
      setIsAccountDialogOpen(false);
      setEditingAccount(null);
    } catch (err) {
      alert(`Error: ${err.message}`);
    }
  };

  const handleDeleteAccount = async (accountId) => {
    if (window.confirm('Are you sure you want to delete this account and all its goals? This action cannot be undone.')) {
        try {
            await api.deleteSavingsAccount(accountId);
            fetchAccounts();
        } catch (err) {
            alert(`Error: ${err.message}`);
        }
    }
  };

  if (loading) return <p>Loading savings accounts...</p>;

  return (
    <div className="space-y-4">
      <div className="flex justify-end">
        <Button onClick={() => { setEditingAccount(null); setIsAccountDialogOpen(true); }}>
          <PlusCircle className="h-4 w-4 mr-2" /> Add Savings Account
        </Button>
      </div>

      <Accordion type="multiple" className="w-full space-y-4">
        {accounts.map(account => (
          <AccordionItem value={`account-${account.id}`} key={account.id} className="border rounded-md px-4">
            <AccordionTrigger>
              <div className="flex justify-between w-full pr-4 items-center">
                <span className="font-semibold text-lg">{account.name} ({account.institution})</span>
                <span className="text-muted-foreground">{new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(account.current_balance)}</span>
              </div>
            </AccordionTrigger>
            <AccordionContent>
              <div className="space-y-4 pt-2">
                <div className="flex justify-end gap-2 border-b pb-4">
                   <Button variant="outline" size="sm" onClick={() => { setEditingAccount(account); setIsAccountDialogOpen(true); }}><Edit className="h-3 w-3 mr-2"/>Edit Account</Button>
                   <Button variant="destructive" size="sm" onClick={() => handleDeleteAccount(account.id)}><Trash2 className="h-3 w-3 mr-2"/>Delete Account</Button>
                </div>
                <div className="text-sm text-center text-muted-foreground py-4">
                    Savings goals are now managed on the main 'Savings' page.
                </div>
              </div>
            </AccordionContent>
          </AccordionItem>
        ))}
      </Accordion>

      <Dialog open={isAccountDialogOpen} onOpenChange={setIsAccountDialogOpen}>
        <DialogContent>
          <DialogHeader><DialogTitle>{editingAccount ? 'Edit' : 'Add'} Savings Account</DialogTitle></DialogHeader>
          <form onSubmit={handleSaveAccount} className="space-y-4 py-4">
            <div><Label>Account Name</Label><Input name="name" defaultValue={editingAccount?.name} required /></div>
            <div><Label>Institution</Label><Input name="institution" defaultValue={editingAccount?.institution} /></div>
            <div><Label>Account Number</Label><Input name="account_number" defaultValue={editingAccount?.account_number} /></div>
             <div><Label>Starting Balance</Label><Input name="current_balance" type="number" step="0.01" defaultValue={editingAccount?.current_balance || '0.00'} required /></div>
            <DialogFooter>
              <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
              <Button type="submit">Save Account</Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>

      <SavingsGoalModal 
        isOpen={isGoalDialogOpen}
        goal={editingGoal}
        accounts={accounts}
        onClose={() => setIsGoalDialogOpen(false)}
        onSave={() => {
            setIsGoalDialogOpen(false);
            fetchAccounts();
        }}
      />
    </div>
  );
}

export default SavingsManager;
--- FILE: ./client/src/components/settings/BudgetUploadTool.jsx ---
import React, { useState, useRef } from 'react';
import * as api from '../../services/api';
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from '../ui/card';
import { Download, Upload } from 'lucide-react';

function BudgetUploadTool() {
  const [message, setMessage] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const fileInputRef = useRef(null);

  const handleDownload = async () => {
    try {
      const csvData = await api.getBudgetTemplate();
      const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      const year = new Date().getFullYear();
      link.setAttribute('download', `budget_template_${year}.csv`);
      document.body.appendChild(link);
      link.click();
      link.parentNode.removeChild(link);
    } catch (err) {
      setError(`Error downloading template: ${err.message}`);
    }
  };

  const handleUpload = async () => {
    const file = fileInputRef.current.files[0];
    if (!file) {
      setError("Please select a file to upload.");
      return;
    }
    setIsLoading(true);
    setMessage('');
    setError('');
    try {
      const response = await api.uploadBudget(file);
      setMessage(response.message);
    } catch (err) {
      setError(`Error uploading budget: ${err.message}`);
    } finally {
      setIsLoading(false);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Budget Upload Tool</CardTitle>
        <CardDescription>
          Download a CSV template of your categories, fill it out, and upload it to set your budgets for the year.
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="flex items-center justify-between p-4 border rounded-lg">
          <p className="font-medium">1. Download Template</p>
          <Button onClick={handleDownload} variant="outline">
            <Download className="h-4 w-4 mr-2" />
            Download
          </Button>
        </div>
        <div className="flex items-center justify-between p-4 border rounded-lg">
          <div className="flex-grow">
            <p className="font-medium">2. Upload Completed File</p>
            <Input type="file" ref={fileInputRef} accept=".csv" className="mt-2" />
          </div>
          <Button onClick={handleUpload} disabled={isLoading} className="ml-4">
            <Upload className="h-4 w-4 mr-2" />
            {isLoading ? "Uploading..." : "Upload"}
          </Button>
        </div>
      </CardContent>
      {(message || error) && (
        <CardFooter>
          {message && <p className="text-sm text-green-600">{message}</p>}
          {error && <p className="text-sm text-red-600">{error}</p>}
        </CardFooter>
      )}
    </Card>
  );
}
export default BudgetUploadTool;

--- FILE: ./client/src/components/settings/ApplicationSettings.jsx ---
import React, { useState, useRef } from 'react';
import * as api from '../../services/api';
import { Button } from '../ui/button';
import { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from '../ui/card';
import ImportProfileManager from './ImportProfileManager';
import { Download, Upload, RotateCw } from 'lucide-react';

function ApplicationSettings() {
  const [message, setMessage] = useState('');
  const [error, setError] = useState('');
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [isBackingUp, setIsBackingUp] = useState(false);
  const [isRestoring, setIsRestoring] = useState(false);
  const fileInputRef = useRef(null);

  const handleRefresh = async () => {
    setIsRefreshing(true);
    setMessage('');
    setError('');
    try {
      const response = await api.refreshHolidays();
      setMessage(response.message);
    } catch (err) {
      setError(`Error: ${err.message}`);
    } finally {
      setIsRefreshing(false);
    }
  };

  const handleBackup = async () => {
    setIsBackingUp(true);
    setMessage('');
    setError('');
    try {
      await api.downloadBackup();
      setMessage('Backup downloaded successfully.');
    } catch (err) {
      setError(`Error creating backup: ${err.message}`);
    } finally {
      setIsBackingUp(false);
    }
  };
  
  const handleRestore = async (event) => {
    const file = event.target.files[0];
    if (!file) {
      return;
    }

    setIsRestoring(true);
    setMessage('');
    setError('');

    try {
      const result = await api.restoreBackup(file);
      setMessage(result.message + " Page will now reload.");
      setTimeout(() => window.location.reload(), 2000);
    } catch (err) {
      setError(`Error restoring from backup: ${err.message}`);
      setIsRestoring(false);
    } 
  };
  
  const triggerFileInput = () => {
    fileInputRef.current.click();
  };

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Data Management</CardTitle>
          <CardDescription>Manage application-wide data sources and tools.</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex items-center justify-between p-4 border rounded-lg mb-4">
            <p className="text-sm font-medium">Public Holidays</p>
            <Button onClick={handleRefresh} disabled={isRefreshing} variant="outline">
              {isRefreshing ? <><RotateCw className="mr-2 h-4 w-4 animate-spin" /> Refreshing...</> : 'Refresh from GOV.UK'}
            </Button>
          </div>
        </CardContent>
        {(message && !error) && (
          <CardFooter>
            <p className="text-sm text-green-600">{message}</p>
          </CardFooter>
        )}
        {error && (
            <CardFooter>
                <p className="text-sm text-red-600">{error}</p>
            </CardFooter>
        )}
      </Card>

      <ImportProfileManager />

      <Card className="border-blue-500">
        <CardHeader>
          <CardTitle>Backup & Restore</CardTitle>
          <CardDescription>Download a full backup of your database or restore from a previous backup file.</CardDescription>
        </CardHeader>
        <CardContent className="flex items-center gap-4">
            <Button onClick={handleBackup} disabled={isBackingUp}>
                {isBackingUp ? 'Generating...' : <> <Download className="mr-2 h-4 w-4" /> Download Full Backup</>}
            </Button>
            <input type="file" ref={fileInputRef} onChange={handleRestore} style={{ display: 'none' }} accept=".db" />
            <Button onClick={triggerFileInput} variant="outline" disabled={isRestoring}>
                {isRestoring ? 'Restoring...' : <><Upload className="mr-2 h-4 w-4" /> Restore from Backup</>}
            </Button>
        </CardContent>
      </Card>
    </div>
  );
}

export default ApplicationSettings;
--- FILE: ./client/src/components/settings/ImportProfileManager.jsx ---
import React, { useState, useEffect } from 'react';
import * as api from '../../services/api';
import { Button } from '../ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogClose } from '../ui/dialog';
import { Input } from '../ui/input';
import { Label } from '../ui/label';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '../ui/table';
import { MoreHorizontal, PlusCircle } from 'lucide-react';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '../ui/dropdown-menu';

function ImportProfileManager() {
    const [profiles, setProfiles] = useState([]);
    const [loading, setLoading] = useState(true);
    const [isDialogOpen, setIsDialogOpen] = useState(false);
    const [editingProfile, setEditingProfile] = useState(null);

    const fetchProfiles = () => {
        api.getAllImportProfiles().then(setProfiles).finally(() => setLoading(false));
    };

    useEffect(() => {
        fetchProfiles();
    }, []);

    const handleSave = async (e) => {
        e.preventDefault();
        const formData = new FormData(e.target);
        const data = Object.fromEntries(formData.entries());
        try {
            if (editingProfile) {
                await api.updateImportProfile(editingProfile.id, data);
            } else {
                await api.createImportProfile(data);
            }
            fetchProfiles();
            setIsDialogOpen(false);
            setEditingProfile(null);
        } catch (err) {
            alert(`Error: ${err.message}`);
        }
    };

    const handleDelete = async (id) => {
        if (window.confirm('Are you sure you want to delete this import profile?')) {
            await api.deleteImportProfile(id);
            fetchProfiles();
        }
    };

    const openDialog = (profile = null) => {
        setEditingProfile(profile);
        setIsDialogOpen(true);
    }

    if(loading) return <p>Loading...</p>

    return (
        <div className="space-y-4">
            <div className="flex justify-end">
                <Button onClick={() => openDialog(null)}><PlusCircle className="h-4 w-4 mr-2"/>Add New Profile</Button>
            </div>
            <div className="rounded-md border">
                <Table>
                    <TableHeader>
                        <TableRow>
                            <TableHead>Profile Name</TableHead>
                            <TableHead>Date Column</TableHead>
                            <TableHead>Description Column</TableHead>
                            <TableHead className="text-right">Actions</TableHead>
                        </TableRow>
                    </TableHeader>
                    <TableBody>
                        {profiles.length > 0 ? profiles.map(profile => (
                            <TableRow key={profile.id}>
                                <TableCell className="font-medium">{profile.profile_name}</TableCell>
                                <TableCell>{profile.date_col}</TableCell>
                                <TableCell>{profile.description_col}</TableCell>
                                <TableCell className="text-right">
                                    <DropdownMenu>
                                        <DropdownMenuTrigger asChild><Button variant="ghost" className="h-8 w-8 p-0"><MoreHorizontal className="h-4 w-4" /></Button></DropdownMenuTrigger>
                                        <DropdownMenuContent align="end">
                                            <DropdownMenuItem onClick={() => openDialog(profile)}>Edit</DropdownMenuItem>
                                            <DropdownMenuItem className="text-red-600" onClick={() => handleDelete(profile.id)}>Delete</DropdownMenuItem>
                                        </DropdownMenuContent>
                                    </DropdownMenu>
                                </TableCell>
                            </TableRow>
                        )) : (
                            <TableRow><TableCell colSpan="4" className="h-24 text-center">No import profiles created yet.</TableCell></TableRow>
                        )}
                    </TableBody>
                </Table>
            </div>

            <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
                <DialogContent className="sm:max-w-[625px]">
                    <DialogHeader><DialogTitle>{editingProfile ? 'Edit' : 'Add'} Import Profile</DialogTitle></DialogHeader>
                    <form onSubmit={handleSave} className="space-y-4 py-4">
                        <div className="grid gap-2">
                            <Label>Profile Name</Label>
                            <Input name="profile_name" defaultValue={editingProfile?.profile_name} placeholder="e.g., My Barclays Account" required />
                        </div>
                        <div className="grid grid-cols-2 gap-4">
                            <div className="grid gap-2"><Label>Date Column Header</Label><Input name="date_col" defaultValue={editingProfile?.date_col} placeholder="Date" required /></div>
                            <div className="grid gap-2"><Label>Description Column Header</Label><Input name="description_col" defaultValue={editingProfile?.description_col} placeholder="Transaction" required /></div>
                        </div>
                        <p className="text-sm text-center text-muted-foreground py-2">--- Amount Columns (use one method) ---</p>
                        <div className="grid gap-2 p-4 border rounded-lg">
                            <Label>Method 1: Single Amount Column</Label>
                            <Input name="amount_col" defaultValue={editingProfile?.amount_col} placeholder="Amount (e.g., -12.34 for debits)" />
                            <p className="text-xs text-muted-foreground">Use this if debits and credits are in the same column (debits are negative).</p>
                        </div>
                        <div className="grid grid-cols-2 gap-4 p-4 border rounded-lg">
                            <div className="grid gap-2">
                                <Label>Method 2: Debit Column</Label>
                                <Input name="debit_col" defaultValue={editingProfile?.debit_col} placeholder="Paid Out" />
                            </div>
                            <div className="grid gap-2">
                                <Label>Credit Column</Label>
                                <Input name="credit_col" defaultValue={editingProfile?.credit_col} placeholder="Paid In" />
                            </div>
                            <p className="text-xs text-muted-foreground col-span-2">Use this if debits and credits are in separate columns.</p>
                        </div>
                        <div className="grid gap-2"><Label>Date Format (Optional)</Label><Input name="date_format" defaultValue={editingProfile?.date_format} placeholder="e.g., YYYY-MM-DD" /><p className="text-xs text-muted-foreground">E.g., DD/MM/YYYY. Leave blank to auto-detect.</p></div>

                        <DialogFooter>
                            <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
                            <Button type="submit">Save Profile</Button>
                        </DialogFooter>
                    </form>
                </DialogContent>
            </Dialog>
        </div>
    )
}
export default ImportProfileManager;
--- FILE: ./client/src/components/settings/VendorManager.jsx ---
import React, { useState, useEffect } from 'react';
import * as api from '../../services/api';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '../ui/table';
import { Input } from '../ui/input';
import { Button, buttonVariants } from '../ui/button';
import { MoreHorizontal } from 'lucide-react';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuLabel, DropdownMenuTrigger } from '../ui/dropdown-menu';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogClose } from '../ui/dialog';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from '../ui/alert-dialog';
import { Label } from '../ui/label';

function VendorManager() {
  const [vendors, setVendors] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [searchTerm, setSearchTerm] = useState('');

  const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [selectedVendor, setSelectedVendor] = useState(null);

  const [newVendorDisplayName, setNewVendorDisplayName] = useState('');
  const [newVendorInternalName, setNewVendorInternalName] = useState('');
  const [editVendorDisplayName, setEditVendorDisplayName] = useState('');

  const fetchVendors = () => {
    setLoading(true);
    api.getAllVendors()
      .then(data => {
        setVendors(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  };

  useEffect(() => {
    fetchVendors();
  }, []);

  const handleAddVendor = async (e) => {
    e.preventDefault();
    try {
      await api.createVendor({ name: newVendorInternalName, displayName: newVendorDisplayName });
      fetchVendors();
      setIsAddDialogOpen(false);
      setNewVendorDisplayName('');
      setNewVendorInternalName('');
    } catch (err) {
      alert(`Error: ${err.message}`);
    }
  };

  const handleEditVendor = (vendor) => {
    setSelectedVendor(vendor);
    setEditVendorDisplayName(vendor.display_name);
    setIsEditDialogOpen(true);
  };

  const handleUpdateVendor = async (e) => {
    e.preventDefault();
    try {
      await api.updateVendor(selectedVendor.id, { name: selectedVendor.name, displayName: editVendorDisplayName });
      fetchVendors();
      setIsEditDialogOpen(false);
      setSelectedVendor(null);
    } catch (err) {
      alert(`Error: ${err.message}`);
    }
  };

  const handleDeleteVendor = async (vendorId) => {
    try {
      await api.deleteVendor(vendorId);
      fetchVendors();
    } catch (err) {
      alert(`Error: ${err.message}`);
    }
  };

  const filteredVendors = vendors.filter(vendor =>
    vendor.display_name.toLowerCase().includes(searchTerm.toLowerCase())
  );

  if (loading) return <p>Loading vendors...</p>;
  if (error) return <p className="text-red-500">Error: {error}</p>;

  return (
    <div className="space-y-4">
        <Dialog open={isAddDialogOpen} onOpenChange={setIsAddDialogOpen}>
            <DialogContent>
                <DialogHeader><DialogTitle>Add New Vendor</DialogTitle></DialogHeader>
                <form onSubmit={handleAddVendor} className="space-y-4">
                    <div className="grid gap-2">
                        <Label htmlFor="add-display-name">Display Name</Label>
                        <Input id="add-display-name" value={newVendorDisplayName} onChange={(e) => setNewVendorDisplayName(e.target.value)} placeholder="e.g., Amazon UK" />
                    </div>
                    <div className="grid gap-2">
                        <Label htmlFor="add-internal-name">Internal Name / Rule</Label>
                        <Input id="add-internal-name" value={newVendorInternalName} onChange={(e) => setNewVendorInternalName(e.target.value)} placeholder="e.g., amazon" />
                    </div>
                    <DialogFooter>
                        <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
                        <Button type="submit">Save Vendor</Button>
                    </DialogFooter>
                </form>
            </DialogContent>
        </Dialog>

        <Dialog open={isEditDialogOpen} onOpenChange={setIsEditDialogOpen}>
            <DialogContent>
                <DialogHeader><DialogTitle>Edit Vendor</DialogTitle></DialogHeader>
                <form onSubmit={handleUpdateVendor} className="space-y-4">
                    <div className="grid gap-2">
                        <Label htmlFor="edit-display-name">Display Name</Label>
                        <Input id="edit-display-name" value={editVendorDisplayName} onChange={(e) => setEditVendorDisplayName(e.target.value)} />
                    </div>
                     <div className="grid gap-2">
                        <Label>Internal Name</Label>
                        <p className="text-sm text-muted-foreground">{selectedVendor?.name}</p>
                    </div>
                    <DialogFooter>
                        <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
                        <Button type="submit">Update Vendor</Button>
                    </DialogFooter>
                </form>
            </DialogContent>
        </Dialog>

        <div className="flex justify-between items-center">
            <Input placeholder="Search vendors..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="max-w-sm" />
            <Button onClick={() => setIsAddDialogOpen(true)}>Add Vendor</Button>
        </div>
        <div className="rounded-md border">
            <Table>
            <TableHeader>
                <TableRow>
                <TableHead>Display Name</TableHead>
                <TableHead>Internal Name (for rules)</TableHead>
                <TableHead className="text-right">Actions</TableHead>
                </TableRow>
            </TableHeader>
            <TableBody>
                {filteredVendors.length > 0 ? (
                filteredVendors.map(vendor => (
                    <TableRow key={vendor.id}>
                    <TableCell className="font-medium">{vendor.display_name}</TableCell>
                    <TableCell className="text-muted-foreground">{vendor.name}</TableCell>
                    <TableCell className="text-right">
                        <AlertDialog>
                            <DropdownMenu>
                                <DropdownMenuTrigger asChild>
                                    <Button variant="ghost" className="h-8 w-8 p-0"><MoreHorizontal className="h-4 w-4" /></Button>
                                </DropdownMenuTrigger>
                                <DropdownMenuContent align="end">
                                    <DropdownMenuLabel>Actions</DropdownMenuLabel>
                                    <DropdownMenuItem onClick={() => handleEditVendor(vendor)}>Edit</DropdownMenuItem>
                                    <AlertDialogTrigger asChild>
                                        <DropdownMenuItem className="text-red-600">Delete</DropdownMenuItem>
                                    </AlertDialogTrigger>
                                </DropdownMenuContent>
                            </DropdownMenu>
                            <AlertDialogContent>
                                <AlertDialogHeader>
                                    <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                                    <AlertDialogDescription>This action cannot be undone. This will set the vendor for any associated transactions to 'null'.</AlertDialogDescription>
                                </AlertDialogHeader>
                                <AlertDialogFooter>
                                    <AlertDialogCancel>Cancel</AlertDialogCancel>
                                    <AlertDialogAction onClick={() => handleDeleteVendor(vendor.id)} className={buttonVariants({ variant: "destructive" })}>Continue</AlertDialogAction>
                                </AlertDialogFooter>
                            </AlertDialogContent>
                        </AlertDialog>
                    </TableCell>
                    </TableRow>
                ))
                ) : (
                <TableRow>
                    <TableCell colSpan={3} className="h-24 text-center">No vendors found.</TableCell>
                </TableRow>
                )}
            </TableBody>
            </Table>
        </div>
    </div>
  );
}

export default VendorManager;
--- FILE: ./client/src/components/layout/Navbar.js ---
import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import { useAuth } from '../../contexts/AuthContext';
import { Button } from '../ui/button';
import { Sheet, SheetContent, SheetTrigger } from '../ui/sheet';
import { Menu, Package2 } from 'lucide-react';

function Navbar() {
  const { logout } = useAuth();
  const location = useLocation();
  const getLinkClasses = (path) => location.pathname === path ? 'text-foreground transition-colors hover:text-foreground' : 'text-muted-foreground transition-colors hover:text-foreground';

  return (
    <header className="sticky top-0 flex h-16 items-center gap-4 border-b bg-background px-4 md:px-6 z-50">
      <nav className="hidden flex-col gap-6 text-lg font-medium md:flex md:flex-row md:items-center md:gap-5 md:text-sm lg:gap-6">
        <Link to="/dashboard" className="flex items-center gap-2 text-lg font-semibold md:text-base"><Package2 className="h-6 w-6" /> <span className="sr-only">Family Budget</span></Link>
        <Link to="/dashboard" className={getLinkClasses('/dashboard')}>Dashboard</Link>
        <Link to="/transactions" className={getLinkClasses('/transactions')}>Transactions</Link>
        <Link to="/budgets" className={getLinkClasses('/budgets')}>Budgets</Link>
        {/* NEW: Added Savings Link */}
        <Link to="/savings" className={getLinkClasses('/savings')}>Savings</Link>
        <Link to="/settings" className={getLinkClasses('/settings')}>Settings</Link>
      </nav>
      <Sheet>
        <SheetTrigger asChild>
          <Button variant="outline" size="icon" className="shrink-0 md:hidden"><Menu className="h-5 w-5" /><span className="sr-only">Toggle navigation menu</span></Button>
        </SheetTrigger>
        <SheetContent side="left">
          <nav className="grid gap-6 text-lg font-medium">
            <Link to="/dashboard" className="flex items-center gap-2 text-lg font-semibold"><Package2 className="h-6 w-6" /> <span className="sr-only">Family Budget</span></Link>
            <Link to="/dashboard" className={getLinkClasses('/dashboard')}>Dashboard</Link>
            <Link to="/transactions" className={getLinkClasses('/transactions')}>Transactions</Link>
            <Link to="/budgets" className={getLinkClasses('/budgets')}>Budgets</Link>
            {/* NEW: Added Savings Link */}
            <Link to="/savings" className={getLinkClasses('/savings')}>Savings</Link>
            <Link to="/settings" className={getLinkClasses('/settings')}>Settings</Link>
          </nav>
        </SheetContent>
      </Sheet>
      <div className="flex w-full items-center justify-end gap-4">
        <Button onClick={logout} variant="outline" size="sm">Logout</Button>
      </div>
    </header>
  );
}
export default Navbar;
--- FILE: ./client/src/components/charts/SavingsDonutChart.jsx ---
import React from 'react';
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip } from 'recharts';

const SavingsDonutChart = ({ goal }) => {
  // FIX: Ensure both savedAmount and target_amount have fallbacks to prevent NaN
  const savedAmount = goal.current_amount || 0;
  const targetAmount = goal.target_amount || 0;
  const remainingAmount = targetAmount - savedAmount;

  const data = [
    { name: 'Saved', value: savedAmount > 0 ? savedAmount : 0 },
    { name: 'Remaining', value: remainingAmount > 0 ? remainingAmount : 0 },
  ];

  // If there's no data, create a single grey circle
  const finalData = (savedAmount === 0 && remainingAmount === 0) ? [{ name: 'Empty', value: 1 }] : data;
  const COLORS = (savedAmount === 0 && remainingAmount === 0) ? ['#e5e7eb'] : ['#16a34a', '#e5e7eb'];

  const formatCurrency = (value) =>
    new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP', minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(value);

  const CustomTooltip = ({ active, payload }) => {
    if (active && payload && payload.length) {
      if (payload[0].name === 'Empty') return null;
      return (
        <div className="p-2 border rounded-md bg-background shadow-sm">
          <p className="font-bold">{`${payload[0].name}: ${new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(payload[0].value)}`}</p>
        </div>
      );
    }
    return null;
  };

  return (
    <div className="flex flex-col items-center">
        <div style={{ width: '100%', height: 150, position: 'relative' }}>
            <ResponsiveContainer>
                <PieChart>
                    <Pie
                        data={finalData}
                        cx="50%"
                        cy="50%"
                        innerRadius={50}
                        outerRadius={70}
                        fill="#8884d8"
                        paddingAngle={finalData.length > 1 ? 5 : 0}
                        dataKey="value"
                        startAngle={90}
                        endAngle={-270}
                    >
                        {finalData.map((entry, index) => (
                            <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} stroke={COLORS[index % COLORS.length]} />
                        ))}
                    </Pie>
                     <Tooltip content={<CustomTooltip />} />
                </PieChart>
            </ResponsiveContainer>
            <div style={{position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', textAlign: 'center' }}>
                <span className="text-xs text-muted-foreground">Saved</span>
                <span className="font-bold text-lg">{formatCurrency(savedAmount)}</span>
            </div>
        </div>
        <p className="text-sm text-muted-foreground mt-2">
            Target: {formatCurrency(targetAmount)}
        </p>
    </div>
  );
};

export default SavingsDonutChart;

--- FILE: ./client/src/components/charts/BudgetBarChart.js ---
import React from 'react';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

function BudgetBarChart({ data }) {
  const formatAsCurrency = (value) =>
    new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(value);

  return (
    <div style={{ width: '100%', aspectRatio: '2 / 1', maxHeight: '400px' }}>
      <ResponsiveContainer>
        <BarChart
          data={data}
          margin={{
            top: 5,
            right: 30,
            left: 20,
            bottom: 5,
          }}
        >
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="category_name" stroke="hsl(var(--muted-foreground))" fontSize={12} />
          <YAxis stroke="hsl(var(--muted-foreground))" fontSize={12} tickFormatter={formatAsCurrency} />
          <Tooltip
            formatter={formatAsCurrency}
            contentStyle={{
              backgroundColor: 'hsl(var(--background))',
              borderColor: 'hsl(var(--border))',
            }}
          />
          <Legend />
          <Bar dataKey="budgeted" fill="hsl(var(--secondary-foreground))" name="Budgeted" radius={[4, 4, 0, 0]} />
          <Bar dataKey="actual" fill="hsl(var(--primary))" name="Actual Spending" radius={[4, 4, 0, 0]} />
        </BarChart>
      </ResponsiveContainer>
    </div>
  );
}

export default BudgetBarChart;

--- FILE: ./client/src/components/budgets/BudgetGrid.jsx ---
import React, { useState, useEffect, useMemo } from 'react';
import * as api from '../../services/api';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '../ui/table';
import { Input } from '../ui/input';
import { Button } from '../ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../ui/select';
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '../ui/accordion';

const formatCurrency = (value) => new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(value || 0);

function BudgetGrid({ year, month }) {
  const [budgetData, setBudgetData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  const fetchBudgetData = async () => {
    setLoading(true);
    setError('');
    try {
      const data = await api.getBudgetsByMonth(year, month);
      setBudgetData(data);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchBudgetData();
  }, [year, month]);

  const handleBudgetChange = (subcategoryId, field, value) => {
    setBudgetData(prevData =>
      prevData.map(item =>
        item.subcategory_id === subcategoryId ? { ...item, [field]: value } : item
      )
    );
  };

  const handleSaveChanges = async () => {
    const budgetsToSave = budgetData.map(item => ({
      subcategory_id: item.subcategory_id,
      year,
      month,
      amount: parseFloat(item.budgeted_amount || 0),
      budget_type: item.budget_type,
    }));
    try {
      await api.setBudgetsBulk(budgetsToSave);
      alert('Budgets saved successfully!');
      fetchBudgetData(); // Re-fetch to get fresh data
    } catch (err) {
      alert(`Error saving budgets: ${err.message}`);
    }
  };

  const groupedBudgets = useMemo(() => {
    return budgetData.reduce((acc, item) => {
      const { category_name, category_id } = item;
      if (!acc[category_id]) {
        acc[category_id] = {
          category_name,
          subcategories: [],
        };
      }
      acc[category_id].subcategories.push(item);
      return acc;
    }, {});
  }, [budgetData]);

  if (loading) return <p>Loading budgets...</p>;
  if (error) return <p className="text-red-500">Error: {error}</p>;

  return (
    <div className="space-y-4">
      <Accordion type="multiple" defaultValue={Object.keys(groupedBudgets)}>
        {Object.entries(groupedBudgets).map(([categoryId, data]) => (
          <AccordionItem key={categoryId} value={categoryId}>
            <AccordionTrigger className="text-xl font-semibold p-4 bg-muted rounded-md">
              {data.category_name}
            </AccordionTrigger>
            <AccordionContent>
              <div className="p-1 border rounded-md">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-[250px]">Subcategory</TableHead>
                      <TableHead>Type</TableHead>
                      <TableHead>Carry-over</TableHead>
                      <TableHead>Recurring Bills</TableHead>
                      <TableHead>Budgeted</TableHead>
                      <TableHead>Actual</TableHead>
                      <TableHead>Remaining</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {data.subcategories.map((sc) => {
                      const effectiveBudget = (parseFloat(sc.budgeted_amount) || 0) + (sc.carryover_amount || 0);
                      const remaining = effectiveBudget - (sc.actual_spending || 0);
                      return (
                        <TableRow key={sc.subcategory_id}>
                          <TableCell className="font-medium">{sc.subcategory_name}</TableCell>
                          <TableCell>
                            <Select
                              value={sc.budget_type}
                              onValueChange={(value) => handleBudgetChange(sc.subcategory_id, 'budget_type', value)}
                            >
                              <SelectTrigger className="w-[120px]"><SelectValue /></SelectTrigger>
                              <SelectContent>
                                <SelectItem value="allowance">Allowance</SelectItem>
                                <SelectItem value="rolling">Rolling</SelectItem>
                              </SelectContent>
                            </Select>
                          </TableCell>
                          <TableCell className="text-muted-foreground">{formatCurrency(sc.carryover_amount)}</TableCell>
                          <TableCell className="text-muted-foreground">{formatCurrency(sc.recurring_bills_total)}</TableCell>
                          <TableCell>
                            <Input
                              type="number"
                              className="w-32"
                              value={sc.budgeted_amount}
                              onChange={(e) => handleBudgetChange(sc.subcategory_id, 'budgeted_amount', e.target.value)}
                              min={sc.recurring_bills_total || 0}
                            />
                          </TableCell>
                          <TableCell>{formatCurrency(sc.actual_spending)}</TableCell>
                          <TableCell className={remaining < 0 ? 'text-destructive' : ''}>
                            {formatCurrency(remaining)}
                          </TableCell>
                        </TableRow>
                      );
                    })}
                  </TableBody>
                </Table>
              </div>
            </AccordionContent>
          </AccordionItem>
        ))}
      </Accordion>
      <div className="flex justify-end mt-4">
        <Button onClick={handleSaveChanges}>Save All Changes</Button>
      </div>
    </div>
  );
}

export default BudgetGrid;
--- FILE: ./client/src/components/SplitTransactionModal.jsx ---
import React, { useState, useEffect } from 'react';
import * as api from '../services/api';
import { Button } from './ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from './ui/dialog';
import { Input } from './ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';
import { Trash2, PlusCircle } from 'lucide-react';
import { Label } from './ui/label';

function SplitTransactionModal({ transaction, allSubcategories, allVendors, onClose, onSave }) {
  const [splits, setSplits] = useState([{ subcategory_id: '', amount: '' }]);
  const [remainingAmount, setRemainingAmount] = useState(0);
  const [selectedVendor, setSelectedVendor] = useState('');
  const [newVendorName, setNewVendorName] = useState('');

  const isOpen = !!transaction;

  useEffect(() => {
    if (transaction) {
      setSplits([{ subcategory_id: '', amount: '' }, { subcategory_id: '', amount: '' }]);
      setRemainingAmount(transaction.amount);
      setSelectedVendor(transaction.vendor_id?.toString() || '');
      setNewVendorName('');
    } else {
      setSplits([{ subcategory_id: '', amount: '' }]);
    }
  }, [transaction]);

  useEffect(() => {
    if (transaction) {
      const totalSplit = splits.reduce((sum, s) => sum + parseFloat(s.amount || 0), 0);
      setRemainingAmount(transaction.amount - totalSplit);
    }
  }, [splits, transaction]);

  const handleSplitChange = (index, field, value) => {
    const newSplits = [...splits];
    newSplits[index][field] = value;
    setSplits(newSplits);
  };

  const addSplit = () => setSplits([...splits, { subcategory_id: '', amount: '' }]);
  const removeSplit = (index) => setSplits(splits.filter((_, i) => i !== index));

  const handleSave = async () => {
    if (Math.abs(remainingAmount) > 0.01) {
      alert('You must allocate the full transaction amount.');
      return;
    }
    try {
      let vendorIdToSave = selectedVendor;
      if (selectedVendor === 'new' && newVendorName) {
        const newVendor = await api.createVendor({ name: newVendorName.toLowerCase().replace(/\s/g, ''), displayName: newVendorName });
        vendorIdToSave = newVendor.id.toString();
      }
      
      const validSplits = splits.filter(s => s.subcategory_id && s.amount > 0);
      if (validSplits.length === 0) {
        alert("You must add at least one valid split line.");
        return;
      }
      
      const payload = {
        splits: validSplits,
        vendor_id: vendorIdToSave
      };

      await api.splitTransaction(transaction.id, payload);
      onSave();
      onClose();
    } catch (error) {
      alert(`Error: ${error.message}`);
    }
  };

  const formatCurrency = (value) => new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(value || 0);

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-2xl">
        <DialogHeader>
          <DialogTitle>Split Transaction</DialogTitle>
          <DialogDescription>Divide the total amount across multiple categories. The remaining amount must be 0.00 to save.</DialogDescription>
        </DialogHeader>
        {transaction && (
          <div className="py-4 space-y-4">
            <div className="flex justify-between items-center bg-muted p-3 rounded-md">
              <div className="text-sm">
                <p>{new Date(transaction.transaction_date).toLocaleDateString("en-GB")}: <span className="font-medium">{transaction.description_original}</span></p>
              </div>
              <div className="text-right">
                <p className="font-bold text-lg">{formatCurrency(transaction.amount)}</p>
                <p className={`text-sm font-medium ${Math.abs(remainingAmount) < 0.01 ? 'text-green-600' : 'text-red-600'}`}>
                  Remaining: {formatCurrency(remainingAmount)}
                </p>
              </div>
            </div>

            <div className="grid gap-2">
              <Label>Vendor</Label>
              <Select onValueChange={setSelectedVendor} value={selectedVendor}>
                <SelectTrigger><SelectValue placeholder="-- Select Vendor --" /></SelectTrigger>
                <SelectContent>
                  {allVendors.map(v => <SelectItem key={v.id} value={v.id.toString()}>{v.display_name}</SelectItem>)}
                  <SelectItem value="new">-- Create New Vendor --</SelectItem>
                </SelectContent>
              </Select>
              {selectedVendor === 'new' && ( <Input placeholder="New Vendor Name" value={newVendorName} onChange={(e) => setNewVendorName(e.target.value)} className="mt-2" /> )}
            </div>

            <div className="space-y-2 max-h-64 overflow-y-auto pr-2">
              {splits.map((split, index) => (
                <div key={index} className="flex items-center gap-2">
                  <Select onValueChange={(value) => handleSplitChange(index, 'subcategory_id', value)} value={split.subcategory_id}>
                      <SelectTrigger><SelectValue placeholder="Select Category" /></SelectTrigger>
                      <SelectContent>{allSubcategories.map(s => <SelectItem key={s.id} value={s.id.toString()}>{s.category_name} &gt; {s.name}</SelectItem>)}</SelectContent>
                  </Select>
                  <Input type="number" placeholder="Amount" value={split.amount} onChange={(e) => handleSplitChange(index, 'amount', e.target.value)} className="w-32"/>
                  <Button variant="ghost" size="icon" onClick={() => removeSplit(index)} disabled={splits.length <= 1}><Trash2 className="h-4 w-4" /></Button>
                </div>
              ))}
            </div>
             <Button variant="outline" size="sm" onClick={addSplit} className="mt-2"><PlusCircle className="h-4 w-4 mr-2"/>Add another split</Button>
          </div>
        )}
        <DialogFooter>
          <Button variant="outline" onClick={onClose}>Cancel</Button>
          <Button onClick={handleSave} disabled={Math.abs(remainingAmount) > 0.01}>Save Split</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

export default SplitTransactionModal;
--- FILE: ./client/src/lib/utils.js ---
import { clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs) {
  return twMerge(clsx(inputs))
}

--- FILE: ./client/src/pages/LoginPage.js ---
import React, { useState } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { Button } from '../components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../components/ui/card';
import { Input } from '../components/ui/input';
import { Label } from '../components/ui/label';

function LoginPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const { login } = useAuth();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    if (!email || !password) {
      setError('Email and password are required.');
      return;
    }
    try {
      await login(email, password);
    } catch (err) {
      setError(err.message || 'Invalid credentials. Please try again.');
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-100">
      <Card className="w-full max-w-sm">
        <CardHeader>
          <CardTitle className="text-2xl">Login</CardTitle>
          <CardDescription>
            Enter your email below to login to your account.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit}>
            <div className="grid gap-4">
              <div className="grid gap-2">
                <Label htmlFor="email">Email</Label>
                <Input
                  id="email"
                  type="email"
                  placeholder="m@example.com"
                  required
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                />
              </div>
              <div className="grid gap-2">
                <Label htmlFor="password">Password</Label>
                <Input
                  id="password"
                  type="password"
                  required
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                />
              </div>
              {error && <p className="text-sm text-red-600">{error}</p>}
              <Button type="submit" className="w-full">
                Login
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

export default LoginPage;
--- FILE: ./client/src/pages/TransactionsPage.js ---
import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import * as api from '../services/api';
import { useAuth } from '../contexts/AuthContext';
import CategorizationModal from '../components/CategorizationModal';
import SplitTransactionModal from '../components/SplitTransactionModal';
import { Button } from '../components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '../components/ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '../components/ui/table';
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '../components/ui/accordion';
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../components/ui/tabs";
import { ArrowUpRight, Trash2, Wand2, Repeat } from 'lucide-react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '../components/ui/dialog';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../components/ui/select';
import RecurringBillsManager from '../components/settings/RecurringBillsManager';

const formatCurrency = (value) => new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP', }).format(value || 0);

function TransactionsTable({ transactions, onCategorize, onSplit, onMakeRecurring }) {
    return (
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Date</TableHead>
              <TableHead>Vendor</TableHead>
              <TableHead>Description</TableHead>
              <TableHead>Category</TableHead>
              <TableHead className="text-right">Amount</TableHead>
              <TableHead className="text-center">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {transactions.map((tx) => (
              <TableRow key={tx.id}>
                <TableCell>{new Date(tx.transaction_date).toLocaleDateString("en-GB")}</TableCell>
                <TableCell className="font-medium">{tx.vendor_name || '--'}</TableCell>
                <TableCell className="text-muted-foreground text-xs">{tx.description_original}</TableCell>
                <TableCell>
                  {tx.is_split ? ( <span className="font-semibold text-purple-600">Split</span> )
                  : tx.category_name ? ( `${tx.category_name} > ${tx.subcategory_name}` )
                  : ( <span className="text-muted-foreground">Uncategorized</span> )}
                </TableCell>
                <TableCell className={`text-right font-bold ${tx.is_debit ? 'text-destructive' : 'text-green-600'}`}>
                  {tx.is_debit ? '-' : '+'}
                  {formatCurrency(tx.amount)}
                </TableCell>
                <TableCell className="text-center space-x-2">
                    {tx.is_split ? (
                      <Button variant="outline" size="sm" onClick={() => onSplit(tx)}>View Split</Button>
                    ) : (
                      <>
                        <Button variant="outline" size="sm" onClick={() => onCategorize(tx)}>{tx.subcategory_id ? 'Edit' : 'Categorize'}</Button>
                        <Button variant="ghost" size="icon" onClick={() => onMakeRecurring(tx)}><Repeat className="h-4 w-4" /></Button>
                        {tx.is_debit && (<Button variant="secondary" size="sm" onClick={() => onSplit(tx)}>Split</Button>)}
                      </>
                    )}
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
    )
}

function IgnoredTransactionsTab({ ignored, onRefresh }) {
  const handleReinstate = async (id) => {
    await api.reinstateTransaction(id);
    onRefresh();
  };

  const handlePurge = async () => {
    if(window.confirm('Are you sure you want to permanently delete all ignored transactions? This cannot be undone.')) {
      await api.purgeIgnoredTransactions();
      onRefresh();
    }
  };

  return (
    <Card>
        <CardHeader>
            <div className="flex justify-between items-center">
                <CardTitle>Ignored Duplicates</CardTitle>
                {ignored.length > 0 && <Button variant="destructive" onClick={handlePurge}><Trash2 className="h-4 w-4 mr-2"/> Purge All</Button>}
            </div>
        </CardHeader>
        <CardContent>
            <Table>
                <TableHeader><TableRow><TableHead>Date</TableHead><TableHead>Description</TableHead><TableHead className="text-right">Amount</TableHead><TableHead className="text-center">Actions</TableHead></TableRow></TableHeader>
                <TableBody>
                    {ignored.length > 0 ? ignored.map(tx => (
                        <TableRow key={tx.id}>
                            <TableCell>{new Date(tx.transaction_date).toLocaleDateString("en-GB")}</TableCell>
                            <TableCell>{tx.description_original}</TableCell>
                            <TableCell className={`text-right ${tx.is_debit ? 'text-destructive' : 'text-green-600'}`}>{formatCurrency(tx.amount)}</TableCell>
                            <TableCell className="text-center"><Button size="sm" onClick={() => handleReinstate(tx.id)}><ArrowUpRight className="h-4 w-4 mr-2"/>Reinstate</Button></TableCell>
                        </TableRow>
                    )) : <TableRow><TableCell colSpan={4} className="h-24 text-center">No ignored transactions found.</TableCell></TableRow>}
                </TableBody>
            </Table>
        </CardContent>
    </Card>
  );
}

function TransactionsPage() {
  const { appSettings } = useAuth();
  const [allTransactions, setAllTransactions] = useState([]);
  const [ignoredTransactions, setIgnoredTransactions] = useState([]);
  const [allSubcategories, setAllSubcategories] = useState([]);
  const [allVendors, setAllVendors] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [uploading, setUploading] = useState(false);
  const [uploadMessage, setUploadMessage] = useState('');
  const fileInputRef = useRef(null);
  const [transactionToCategorize, setTransactionToCategorize] = useState(null);
  const [transactionToSplit, setTransactionToSplit] = useState(null);
  const [filter, setFilter] = useState('all');
  const [isRecurringModalOpen, setIsRecurringModalOpen] = useState(false);
  const [transactionToMakeRecurring, setTransactionToMakeRecurring] = useState(null);
  const [isImportModalOpen, setIsImportModalOpen] = useState(false);
  const [importProfiles, setImportProfiles] = useState([]);
  const [selectedProfileId, setSelectedProfileId] = useState('');
  const [isApplyingRules, setIsApplyingRules] = useState(false);

  const fetchPageData = useCallback(async () => {
    try {
      setLoading(true);
      const [transactionsData, ignoredData, subcategoriesData, vendorsData, profilesData] = await Promise.all([
        api.getAllTransactions(),
        api.getIgnoredTransactions(),
        api.getAllSubcategories(),
        api.getAllVendors(),
        api.getAllImportProfiles()
      ]);
      setAllTransactions(transactionsData);
      setIgnoredTransactions(ignoredData);
      setAllSubcategories(subcategoriesData);
      setAllVendors(vendorsData);
      setImportProfiles(profilesData);
    } catch (err) { setError(err.message); }
    finally { setLoading(false); }
  }, []);

  useEffect(() => {
    fetchPageData();
  }, [fetchPageData]);

  const filteredTransactions = useMemo(() => {
    if (filter === 'all') return allTransactions;
    if (filter === 'uncategorized') return allTransactions.filter(tx => !tx.subcategory_id && !tx.is_split);
    if (filter === 'spending') return allTransactions.filter(tx => tx.is_debit);
    if (filter === 'income') return allTransactions.filter(tx => !tx.is_debit);
    return allTransactions;
  }, [allTransactions, filter]);

  const groupedTransactions = useMemo(() => {
    if (!appSettings) return {};
    const fiscalDayStart = appSettings.fiscal_day_start;
    return filteredTransactions.reduce((acc, tx) => {
      const txDate = new Date(tx.transaction_date);
      let month = txDate.getMonth();
      let year = txDate.getFullYear();
      if (txDate.getDate() >= fiscalDayStart) { month += 1; }
      if (month > 11) { month = 0; year += 1; }
      const financialMonth = new Date(year, month, 1).toLocaleString('en-GB', { month: 'long', year: 'numeric' });
      if (!acc[financialMonth]) { acc[financialMonth] = []; }
      acc[financialMonth].push(tx);
      return acc;
    }, {});
  }, [filteredTransactions, appSettings]);

  const handleOpenImportModal = () => {
    if (importProfiles.length === 0) {
      alert("No import profiles found. Please create one in Settings > Import Profiles first.");
      return;
    }
    setSelectedProfileId(importProfiles.length > 0 ? importProfiles[0].id.toString() : '');
    setIsImportModalOpen(true);
  };

  const handleFileSelect = async (event) => {
    const file = event.target.files[0];
    if (!file) return;
    setIsImportModalOpen(false);
    setUploading(true);
    setUploadMessage('');
    setError('');
    try {
      const result = await api.uploadTransactionsFile(file, selectedProfileId);
      setUploadMessage(result.message);
      fetchPageData();
    } catch (err) { setError(err.message); }
    finally {
      setUploading(false);
      if(fileInputRef.current) { fileInputRef.current.value = ""; }
    }
  };

  const handleApplyRules = async () => {
    setIsApplyingRules(true);
    setError('');
    try {
        const result = await api.applyCategorizationRules();
        alert(result.message);
        fetchPageData();
    } catch (err) { setError(err.message); }
    finally { setIsApplyingRules(false); }
  };

  const handleMakeRecurring = (transaction) => {
    setTransactionToMakeRecurring(transaction);
    setIsRecurringModalOpen(true);
  };

  return (
    <>
      <div className="container mx-auto p-4 md:p-6">
        <div className="flex items-center justify-between mb-6">
          <h1 className="text-3xl font-bold">Transactions</h1>
          <div className="flex items-center gap-2">
            <Button variant={filter === 'all' ? 'default' : 'outline'} size="sm" onClick={() => setFilter('all')}>All</Button>
            <Button variant={filter === 'spending' ? 'default' : 'outline'} size="sm" onClick={() => setFilter('spending')}>Spending</Button>
            <Button variant={filter === 'income' ? 'default' : 'outline'} size="sm" onClick={() => setFilter('income')}>Income</Button>
            <Button variant={filter === 'uncategorized' ? 'destructive' : 'outline'} size="sm" onClick={() => setFilter('uncategorized')}>Uncategorized</Button>
            <Button onClick={handleApplyRules} variant="outline" size="sm" disabled={isApplyingRules}><Wand2 className="h-4 w-4 mr-2" />{isApplyingRules ? "Applying..." : "Apply Rules"}</Button>
            <Button onClick={handleOpenImportModal} size="sm" disabled={uploading}>{uploading ? 'Uploading...' : 'Upload Statement'}</Button>
          </div>
        </div>
        {uploadMessage && <p className="text-green-600 mb-4">{uploadMessage}</p>}
        {error && <p className="text-red-600 mb-4">Error: {error}</p>}

        <Tabs defaultValue="all-transactions">
            <TabsList className="grid w-full grid-cols-2"><TabsTrigger value="all-transactions">All Transactions</TabsTrigger><TabsTrigger value="ignored">Ignored Duplicates</TabsTrigger></TabsList>
            <TabsContent value="all-transactions">
                 <Accordion type="multiple" defaultValue={Object.keys(groupedTransactions).slice(0, 1)} className="w-full space-y-4">
                    {Object.keys(groupedTransactions).map(month => (
                        <AccordionItem key={month} value={month}>
                            <AccordionTrigger className="text-xl font-semibold p-4 bg-muted rounded-md">{month}</AccordionTrigger>
                            <AccordionContent><div className="p-1"><TransactionsTable transactions={groupedTransactions[month]} onCategorize={setTransactionToCategorize} onSplit={setTransactionToSplit} onMakeRecurring={handleMakeRecurring} /></div></AccordionContent>
                        </AccordionItem>
                    ))}
                </Accordion>
            </TabsContent>
            <TabsContent value="ignored"><IgnoredTransactionsTab ignored={ignoredTransactions} onRefresh={fetchPageData}/></TabsContent>
        </Tabs>
      </div>

      <CategorizationModal transaction={transactionToCategorize} allSubcategories={allSubcategories} allVendors={allVendors} onClose={() => setTransactionToCategorize(null)} onSave={fetchPageData} />
      <SplitTransactionModal transaction={transactionToSplit} allSubcategories={allSubcategories} allVendors={allVendors} onClose={() => setTransactionToSplit(null)} onSave={fetchPageData} />
      
      {isRecurringModalOpen && (
          <RecurringBillsManager isOpen={isRecurringModalOpen} onClose={() => setIsRecurringModalOpen(false)} billToCreateFromTx={transactionToMakeRecurring} onSave={fetchPageData} />
      )}

      <Dialog open={isImportModalOpen} onOpenChange={setIsImportModalOpen}>
        <DialogContent>
            <DialogHeader><DialogTitle>Select Import Profile</DialogTitle></DialogHeader>
            <div className="py-4">
                <Select onValueChange={setSelectedProfileId} value={selectedProfileId}>
                    <SelectTrigger><SelectValue placeholder="Select a profile..." /></SelectTrigger>
                    <SelectContent>{importProfiles.map(p => <SelectItem key={p.id} value={p.id.toString()}>{p.profile_name}</SelectItem>)}</SelectContent>
                </Select>
            </div>
            <DialogFooter>
                <input type="file" ref={fileInputRef} style={{ display: 'none' }} onChange={handleFileSelect} accept=".csv" />
                <Button onClick={() => { if(selectedProfileId) { fileInputRef.current.click() } else { alert("Please select a profile first.")} }}>Select File</Button>
            </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}

export default TransactionsPage;
--- FILE: ./client/src/pages/SettingsPage.js ---
import React from 'react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../components/ui/tabs';
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from '../components/ui/card';
import CategoryManager from '../components/settings/CategoryManager';
import VendorManager from '../components/settings/VendorManager';
import RecurringBillsManager from '../components/settings/RecurringBillsManager';
import ApplicationSettings from '../components/settings/ApplicationSettings';
import SavingsManager from '../components/settings/SavingsManager';
import PlannedIncomeManager from '../components/settings/PlannedIncomeManager';
import BudgetUploadTool from '../components/settings/BudgetUploadTool';

function SettingsPage() {
  return (
    <div className="container mx-auto p-4 md:p-6">
      <h1 className="text-3xl font-bold mb-6">Settings</h1>
      <Tabs defaultValue="categories" className="w-full">
        <TabsList className="grid w-full grid-cols-1 md:grid-cols-7">
          <TabsTrigger value="categories">Categories</TabsTrigger>
          <TabsTrigger value="vendors">Vendors</TabsTrigger>
          <TabsTrigger value="bills">Recurring Bills</TabsTrigger>
          <TabsTrigger value="income">Planned Income</TabsTrigger>
          <TabsTrigger value="savings_accounts">Savings Accounts</TabsTrigger>
          <TabsTrigger value="budget_tools">Budget Tools</TabsTrigger>
          <TabsTrigger value="app">Application</TabsTrigger>
        </TabsList>

        <TabsContent value="categories">
          <Card>
            <CardHeader><CardTitle>Manage Categories</CardTitle><CardDescription>Add, edit, or delete your spending categories and link them to savings accounts.</CardDescription></CardHeader>
            <CardContent className="space-y-2"><CategoryManager /></CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="vendors">
          <Card>
            <CardHeader><CardTitle>Manage Vendors</CardTitle><CardDescription>Clean up and manage vendor names.</CardDescription></CardHeader>
            <CardContent className="space-y-2"><VendorManager /></CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="bills">
          <Card>
            <CardHeader><CardTitle>Manage Recurring Bills</CardTitle><CardDescription>Set up scheduled payments for the cashflow forecast.</CardDescription></CardHeader>
            <CardContent className="space-y-2"><RecurringBillsManager /></CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="income">
           <Card>
            <CardHeader><CardTitle>Manage Planned Income</CardTitle><CardDescription>Set up recurring income sources like salaries.</CardDescription></CardHeader>
            <CardContent className="space-y-2"><PlannedIncomeManager /></CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="savings_accounts">
           <Card>
            <CardHeader><CardTitle>Manage Savings Accounts</CardTitle><CardDescription>Define your savings accounts. Goals are managed on the Savings page.</CardDescription></CardHeader>
            <CardContent className="space-y-2"><SavingsManager /></CardContent>
          </Card>
        </TabsContent>
        
        <TabsContent value="budget_tools">
            <BudgetUploadTool />
        </TabsContent>

        <TabsContent value="app">
          <ApplicationSettings />
        </TabsContent>

      </Tabs>
    </div>
  );
}

export default SettingsPage;
--- FILE: ./client/src/pages/InitialSetupPage.jsx ---
import React, { useState, useRef } from 'react';
import * as api from '../services/api';
import { useAuth } from '../contexts/AuthContext';
import { Button } from '../components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../components/ui/card';
import { Input } from '../components/ui/input';
import { Label } from '../components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../components/ui/select';

function RestoreBackup({ onRestored }) {
    const [isRestoring, setIsRestoring] = useState(false);
    const [error, setError] = useState('');
    const fileInputRef = useRef(null);

    const handleFileChange = async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        setIsRestoring(true);
        setError('');
        try {
            const result = await api.restoreBackup(file);
            alert(result.message + "\n\nThe application will now reload.");
            // Give the server time to restart before re-initializing the app
            setTimeout(() => {
                onRestored();
                window.location.reload(); // Force a full page reload
            }, 3000); 
        } catch (err) {
            setError(err.message);
            setIsRestoring(false);
        }
    };

    return (
        <Card className="mt-8 border-dashed">
            <CardHeader>
                <CardTitle>Restore From Backup</CardTitle>
                <CardDescription>If you have a backup file, you can restore the application to its previous state here. The application will restart.</CardDescription>
            </CardHeader>
            <CardContent className="flex items-center gap-4">
                <Input type="file" ref={fileInputRef} onChange={handleFileChange} accept=".db" disabled={isRestoring} className="hidden" id="backup-file-input"/>
                <Button onClick={() => fileInputRef.current.click()} disabled={isRestoring} className="w-full">
                    {isRestoring ? 'Restoring...' : 'Upload & Restore'}
                </Button>
            </CardContent>
            {error && <CardContent><p className="text-sm text-red-600">{error}</p></CardContent>}
        </Card>
    );
}


function InitialSetupPage() {
  const [jurisdiction, setJurisdiction] = useState('');
  const [fiscalDayStart, setFiscalDayStart] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const { initializeApp, login } = useAuth();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setIsLoading(true);

    if (!jurisdiction || !fiscalDayStart || !email || !password) {
      setError('All fields are required.');
      setIsLoading(false);
      return;
    }
    try {
      await api.register(email, password);
      const tempLoginData = await api.login(email, password);
      if (!tempLoginData.token) throw new Error("Failed to acquire temporary token for setup.");
      
      await api.saveAppSettings({
        jurisdiction,
        fiscal_day_start: parseInt(fiscalDayStart, 10),
      }, tempLoginData.token);

      await login(email, password);

    } catch (err) {
      setError(err.message);
      localStorage.removeItem('authToken');
    } finally {
        setIsLoading(false);
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-100 p-4">
      <div className="w-full max-w-lg">
        <Card>
          <CardHeader>
            <CardTitle className="text-2xl">Initial Application Setup</CardTitle>
            <CardDescription>
              Welcome! Please create your admin account and configure your financial calendar.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleSubmit} className="space-y-6">
              <div className="space-y-2">
                  <Label>Admin Account</Label>
                  <div className="grid grid-cols-2 gap-4">
                      <Input type="email" placeholder="Email" value={email} onChange={e => setEmail(e.target.value)} required disabled={isLoading}/>
                      <Input type="password" placeholder="Password" value={password} onChange={e => setPassword(e.target.value)} required disabled={isLoading}/>
                  </div>
              </div>
  
              <div className="space-y-2">
                <Label htmlFor="jurisdiction">Your Jurisdiction</Label>
                <Select onValueChange={setJurisdiction} value={jurisdiction} disabled={isLoading}>
                  <SelectTrigger id="jurisdiction"><SelectValue placeholder="Select your region..." /></SelectTrigger>
                  <SelectContent>
                    <SelectItem value="england-and-wales">England and Wales</SelectItem>
                    <SelectItem value="scotland">Scotland</SelectItem>
                    <SelectItem value="northern-ireland">Northern Ireland</SelectItem>
                  </SelectContent>
                </Select>
              </div>
  
              <div className="space-y-2">
                <Label htmlFor="fiscalDay">Financial Month Start Day</Label>
                <Input
                  id="fiscalDay"
                  type="number"
                  min="1"
                  max="28"
                  placeholder="e.g., 28"
                  value={fiscalDayStart}
                  onChange={(e) => setFiscalDayStart(e.target.value)}
                  required
                  disabled={isLoading}
                />
              </div>
  
              {error && <p className="text-sm text-red-600">{error}</p>}
  
              <Button type="submit" className="w-full" disabled={isLoading}>
                  {isLoading ? 'Saving...' : 'Save Configuration and Start'}
              </Button>
            </form>
          </CardContent>
        </Card>

        <RestoreBackup onRestored={initializeApp} />
      </div>
    </div>
  );
}

export default InitialSetupPage;
--- FILE: ./client/src/pages/SavingsPage.jsx ---
import React, { useState, useEffect } from 'react';
import * as api from '../services/api';
import SavingsDonutChart from '../components/charts/SavingsDonutChart';
import { Card, CardContent, CardHeader, CardTitle } from '../components/ui/card';
import { Button } from '../components/ui/button';
import { PlusCircle } from 'lucide-react';
import SavingsGoalModal from '../components/settings/SavingsGoalModal'; // We'll create this

function SavingsPage() {
  const [savingsAccounts, setSavingsAccounts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [isGoalModalOpen, setIsGoalModalOpen] = useState(false);
  const [editingGoal, setEditingGoal] = useState(null);

  const fetchSavings = async () => {
    try {
      setLoading(true);
      const savings = await api.getAllSavingsAccounts();
      setSavingsAccounts(savings);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchSavings();
  }, []);

  const allGoals = savingsAccounts.flatMap(acc => acc.goals.map(g => ({...g, accountName: acc.name})));

  return (
    <div className="container mx-auto p-4 md:p-6 space-y-6">
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-3xl font-bold">Savings Goals</h1>
        <Button onClick={() => { setEditingGoal(null); setIsGoalModalOpen(true); }}><PlusCircle className="h-4 w-4 mr-2" /> Add Savings Goal</Button>
      </div>

      {loading && <p>Loading savings goals...</p>}
      {error && <p className="text-red-500">Error: {error}</p>}

      {!loading && allGoals.length > 0 ? (
        <div className="grid gap-8 grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
          {allGoals.map(goal => (
             <Card key={goal.id}>
                <CardHeader>
                    <CardTitle className="flex justify-between items-center">
                        {goal.title}
                        <Button variant="ghost" size="sm" onClick={() => { setEditingGoal(goal); setIsGoalModalOpen(true); }}>Edit</Button>
                    </CardTitle>
                </CardHeader>
                <CardContent className="pt-0">
                     <SavingsDonutChart goal={goal} />
                </CardContent>
             </Card>
          ))}
        </div>
      ) : (
        !loading && <p className="text-center text-muted-foreground">You have not created any savings goals yet.</p>
      )}

      <SavingsGoalModal 
        isOpen={isGoalModalOpen}
        goal={editingGoal}
        accounts={savingsAccounts}
        onClose={() => setIsGoalModalOpen(false)}
        onSave={() => {
            setIsGoalModalOpen(false);
            fetchSavings();
        }}
      />
    </div>
  );
}

export default SavingsPage;
--- FILE: ./client/src/pages/Dashboard.js ---
import React, { useState, useEffect } from 'react';
import * as api from '../services/api';
import SavingsDonutChart from '../components/charts/SavingsDonutChart';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '../components/ui/card';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { CheckCircle, XCircle } from 'lucide-react';

const formatCurrency = (value) => new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(value || 0);

function Dashboard() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError('');
        const dashboardData = await api.getDashboardData();
        setData(dashboardData);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  if (loading) return <p className="p-4 md:p-6">Loading dashboard...</p>;
  if (error) return <p className="p-4 md:p-6 text-red-600">Error: {error}</p>;
  if (!data) return null;

  return (
    <div className="container mx-auto p-4 md:p-6 space-y-6">
      <h1 className="text-3xl font-bold">Dashboard</h1>

      {/* Top Row Metrics */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
        <Card>
          <CardHeader><CardTitle>Income Received</CardTitle></CardHeader>
          <CardContent><p className="text-2xl font-bold text-green-600">{formatCurrency(data.summary.totalIncome)}</p></CardContent>
        </Card>
        <Card>
          <CardHeader><CardTitle>Total Spending</CardTitle></CardHeader>
          <CardContent><p className="text-2xl font-bold text-red-600">{formatCurrency(data.summary.totalSpending)}</p></CardContent>
        </Card>
        <Card>
          <CardHeader><CardTitle>Planned Surplus</CardTitle></CardHeader>
          <CardContent><p className="text-2xl font-bold">{formatCurrency(data.summary.plannedSurplus)}</p></CardContent>
        </Card>
        <Card>
          <CardHeader><CardTitle>Current Surplus</CardTitle></CardHeader>
          <CardContent><p className="text-2xl font-bold text-blue-600">{formatCurrency(data.summary.currentSurplus)}</p></CardContent>
        </Card>
      </div>

      {/* Second Row: Income Details & In-Month Cashflow */}
      <div className="grid gap-6 md:grid-cols-2">
        <Card>
            <CardHeader><CardTitle>Monthly Income Status</CardTitle></CardHeader>
            <CardContent>
                <ul className="space-y-2">
                    {data.incomeStatus.map(item => (
                        <li key={item.id} className="flex items-center justify-between text-sm">
                            <span className="text-muted-foreground">{item.source_name}</span>
                            <div className="flex items-center gap-2">
                                <span className="font-medium">{formatCurrency(item.amount)}</span>
                                {item.received ? <CheckCircle className="h-5 w-5 text-green-500"/> : <XCircle className="h-5 w-5 text-gray-400"/>}
                            </div>
                        </li>
                    ))}
                </ul>
            </CardContent>
        </Card>
        <Card>
          <CardHeader><CardTitle>In-Month Cashflow</CardTitle><CardDescription>Daily actual cashflow for the current financial month.</CardDescription></CardHeader>
          <CardContent>
            <ResponsiveContainer width="100%" height={200}>
              <LineChart data={data.inMonthCashflow}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" tickFormatter={(tick) => new Date(tick).getDate()} />
                <YAxis tickFormatter={formatCurrency} />
                <Tooltip formatter={(value) => formatCurrency(value)} />
                <Line type="monotone" dataKey="actual" stroke="hsl(var(--primary))" strokeWidth={2} dot={false} name="Actual Balance" />
              </LineChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>
      </div>
      
      {/* Savings Goals */}
      {data.savingsGoals.length > 0 && (
        <Card>
          <CardHeader><CardTitle>Savings Goals Progress</CardTitle></CardHeader>
          <CardContent className="grid gap-8 grid-cols-2 md:grid-cols-3 lg:grid-cols-4">
            {data.savingsGoals.map(goal => (<SavingsDonutChart key={goal.id} goal={goal} />))}
          </CardContent>
        </Card>
      )}

      {/* 12-Month Forecast */}
      <Card>
        <CardHeader><CardTitle>12-Month Cashflow Forecast</CardTitle></CardHeader>
        <CardContent>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={data.twelveMonthForecast}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" tickFormatter={(tick) => new Date(tick).toLocaleDateString('en-GB', { month: 'short' })} />
              <YAxis tickFormatter={formatCurrency} domain={['auto', 'auto']} />
              <Tooltip formatter={(value) => formatCurrency(value)} />
              <Legend />
              <Line type="monotone" dataKey="running_balance" name="Projected Balance" stroke="hsl(var(--primary))" strokeWidth={2} dot={false} />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>
    </div>
  );
}

export default Dashboard;
--- FILE: ./client/src/pages/BudgetsPage.jsx ---
import React, { useState } from 'react';
import BudgetGrid from '../components/budgets/BudgetGrid';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../components/ui/select';

const MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
const currentYear = new Date().getFullYear();
const YEARS = Array.from({ length: 5 }, (_, i) => currentYear - 2 + i);

function BudgetsPage() {
  const [selectedMonth, setSelectedMonth] = useState(new Date().getMonth() + 1);
  const [selectedYear, setSelectedYear] = useState(currentYear);

  return (
    <div className="container mx-auto p-4 md:p-6">
      <div className="flex flex-col md:flex-row md:items-center md:justify-between mb-6 gap-4">
        <h1 className="text-3xl font-bold">Budgets</h1>
        <div className="flex items-center gap-2">
          <Select value={selectedMonth.toString()} onValueChange={(val) => setSelectedMonth(parseInt(val))}>
            <SelectTrigger className="w-[180px]"><SelectValue placeholder="Select Month" /></SelectTrigger>
            <SelectContent>{MONTHS.map((month, index) => (<SelectItem key={month} value={(index + 1).toString()}>{month}</SelectItem>))}</SelectContent>
          </Select>
          <Select value={selectedYear.toString()} onValueChange={(val) => setSelectedYear(parseInt(val))}>
            <SelectTrigger className="w-[120px]"><SelectValue placeholder="Select Year" /></SelectTrigger>
            <SelectContent>{YEARS.map(year => (<SelectItem key={year} value={year.toString()}>{year}</SelectItem>))}</SelectContent>
          </Select>
        </div>
      </div>
      <BudgetGrid year={selectedYear} month={selectedMonth} />
    </div>
  );
}
export default BudgetsPage;

--- FILE: ./client/src/App.js ---
import React, { useEffect } from 'react';
import { Routes, Route, Navigate, Outlet } from 'react-router-dom';
import { useAuth } from './contexts/AuthContext';
import LoginPage from './pages/LoginPage';
import Dashboard from './pages/Dashboard';
import TransactionsPage from './pages/TransactionsPage';
import BudgetsPage from './pages/BudgetsPage';
import SavingsPage from './pages/SavingsPage';
import SettingsPage from './pages/SettingsPage';
import InitialSetupPage from './pages/InitialSetupPage';
import Navbar from './components/layout/Navbar';
import { Button } from './components/ui/button';

const AppLayout = () => ( <div><Navbar /><main><Outlet /></main></div> );

const LoadingScreen = ({ message }) => (
  <div className="flex items-center justify-center h-screen bg-background">
    <p className="text-muted-foreground">{message}</p>
  </div>
);

const ErrorScreen = ({ error, onRetry }) => (
  <div className="flex flex-col items-center justify-center h-screen bg-background gap-4">
      <h2 className="text-xl font-semibold text-destructive">Application Error</h2>
      <p className="text-muted-foreground max-w-md text-center">{error}</p>
      <Button onClick={onRetry}>Retry Connection</Button>
  </div>
);

function App() {
  const { isAuthenticated, appSettings, isLoading, initError, initializeApp } = useAuth();

  // --- DIAGNOSTIC STEP ---
  // This will print the settings object to the browser console when it changes.
  useEffect(() => {
    console.log("Auth context has updated. Received settings:", appSettings);
  }, [appSettings]);

  if (isLoading) {
    return <LoadingScreen message="Loading..." />;
  }

  if (initError) {
    return <ErrorScreen error={initError} onRetry={initializeApp} />;
  }

  // If setup is NOT complete, always force the user to the setup page.
  if (appSettings && !appSettings.setup_complete) {
    return (
      <Routes>
        <Route path="/setup" element={<InitialSetupPage />} />
        <Route path="*" element={<Navigate to="/setup" replace />} />
      </Routes>
    );
  }

  // If setup IS complete, use the normal authentication flow.
  return (
    <Routes>
      {isAuthenticated ? (
        <Route element={<AppLayout />}>
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/transactions" element={<TransactionsPage />} />
          <Route path="/budgets" element={<BudgetsPage />} />
          <Route path="/savings" element={<SavingsPage />} />
          <Route path="/settings" element={<SettingsPage />} />
          <Route path="*" element={<Navigate to="/dashboard" replace />} />
        </Route>
      ) : (
        <>
          <Route path="/login" element={<LoginPage />} />
          <Route path="*" element={<Navigate to="/login" replace />} />
        </>
      )}
    </Routes>
  );
}

export default App;
--- FILE: ./client/src/services/api.js ---
const API_BASE_URL = '/api';

async function fetchApi(url, options = {}, isFile = false) {
  const token = localStorage.getItem('authToken');
  const headers = isFile ? {} : { 'Content-Type': 'application/json' };
  if (token) { headers['Authorization'] = `Bearer ${token}`; }
  
  if (options.token) {
    headers['Authorization'] = `Bearer ${options.token}`;
  }

  const finalOptions = { ...options, headers };
  delete finalOptions.token;

  const response = await fetch(`${API_BASE_URL}${url}`, finalOptions);
  
  if (response.status === 204) return;

  const contentType = response.headers.get("content-type");
  
  if (contentType && contentType.includes("application/json")) {
      const data = await response.json();
      if (!response.ok) { throw new Error(data.message || 'An API error occurred.'); }
      return data;
  }
  
  if (response.ok && (contentType?.includes('application/x-sqlite3') || contentType?.includes('text/csv'))) {
      return await response.blob();
  }
  
  if (response.ok) {
    return response.text();
  }

  const textData = await response.text();
  throw new Error(textData || 'An API error occurred.');
}

// AUTH
export async function login(email, password) { return fetchApi('/auth/login', { method: 'POST', body: JSON.stringify({ email, password }) }); }
export async function register(email, password) { return fetchApi('/auth/register', { method: 'POST', body: JSON.stringify({ email, password }) }); }

// SETTINGS & PROFILES
export async function getAppSettings() { return fetchApi('/settings'); }
export async function saveAppSettings(settings, token) { return fetchApi('/settings', { method: 'POST', body: JSON.stringify(settings), token: token }); }
export async function refreshHolidays() { return fetchApi('/settings/refresh-holidays', { method: 'POST', }); }
export async function getAllImportProfiles() { return fetchApi('/import-profiles'); }
export async function createImportProfile(profileData) { return fetchApi('/import-profiles', { method: 'POST', body: JSON.stringify(profileData) }); }
export async function updateImportProfile(id, profileData) { return fetchApi(`/import-profiles/${id}`, { method: 'PUT', body: JSON.stringify(profileData) }); }
export async function deleteImportProfile(id) { return fetchApi(`/import-profiles/${id}`, { method: 'DELETE' }); }


// TRANSACTIONS
export async function uploadTransactionsFile(file, profileId) { 
    const formData = new FormData(); 
    formData.append('transactionsFile', file);
    formData.append('profileId', profileId);
    return fetchApi('/transactions/upload', { method: 'POST', body: formData }, true); 
}
export async function getAllTransactions() { return fetchApi('/transactions'); }
export async function categorizeTransaction(transactionId, data) { return fetchApi(`/transactions/${transactionId}/categorize`, { method: 'PUT', body: JSON.stringify(data) }); }
export async function updateTransactionVendor(transactionId, vendorId) { return fetchApi(`/transactions/${transactionId}/vendor`, { method: 'PUT', body: JSON.stringify({ vendor_id: vendorId }) }); }
export async function splitTransaction(transactionId, data) { return fetchApi(`/transactions/${transactionId}/split`, { method: 'POST', body: JSON.stringify({ splits: data.splits, vendor_id: data.vendor_id }) }); }
export async function getIgnoredTransactions() { return fetchApi('/transactions/ignored'); }
export async function reinstateTransaction(id) { return fetchApi(`/transactions/ignored/${id}/reinstate`, { method: 'POST', }); }
export async function purgeIgnoredTransactions() { return fetchApi('/transactions/ignored/purge', { method: 'DELETE', }); }
export async function applyCategorizationRules() { return fetchApi('/transactions/apply-rules', { method: 'POST', }); }

// DASHBOARD & FORECAST
export async function getDashboardData() { return fetchApi('/dashboard'); }
export async function getForecast() { return fetchApi('/forecast/cashflow'); }

// DATA MANAGEMENT
export async function getCategoriesWithSubcategories() { return fetchApi('/categories?with_subcategories=true'); }
export async function createCategory(name) { return fetchApi('/categories', { method: 'POST', body: JSON.stringify({ name }) }); }
export async function updateCategory(id, data) { return fetchApi(`/categories/${id}`, { method: 'PUT', body: JSON.stringify(data) }); }
export async function deleteCategory(id) { return fetchApi(`/categories/${id}`, { method: 'DELETE', }); }
export async function createSubcategory(categoryId, name) { return fetchApi(`/categories/${categoryId}/subcategories`, { method: 'POST', body: JSON.stringify({ name }) }); }
export async function deleteSubcategory(categoryId, subcategoryId) { return fetchApi(`/categories/${categoryId}/subcategories/${subcategoryId}`, { method: 'DELETE', }); }
export async function getAllSubcategories() { return fetchApi('/subcategories/all'); }
export async function getAllVendors() { return fetchApi('/vendors'); }
export async function createVendor(vendorData) { return fetchApi('/vendors', { method: 'POST', body: JSON.stringify(vendorData) }); }
export async function updateVendor(id, vendorData) { return fetchApi(`/vendors/${id}`, { method: 'PUT', body: JSON.stringify(vendorData) }); }
export async function deleteVendor(id) { return fetchApi(`/vendors/${id}`, { method: 'DELETE', }); }
export async function getActiveRecurringBills() { return fetchApi('/recurring-bills'); }
export async function createRecurringBill(billData) { return fetchApi('/recurring-bills', { method: 'POST', body: JSON.stringify(billData) }); }
export async function updateRecurringBill(id, billData) { return fetchApi(`/recurring-bills/${id}`, { method: 'PUT', body: JSON.stringify(billData) }); }
export async function deactivateRecurringBill(id) { return fetchApi(`/recurring-bills/${id}`, { method: 'DELETE', }); }

// BUDGETS
export async function getBudgetsByMonth(year, month) { return fetchApi(`/budgets/${year}/${month}`); }
export async function setBudgetsBulk(budgets) { return fetchApi('/budgets/bulk', { method: 'POST', body: JSON.stringify({ budgets }) }); }
export async function getBudgetTemplate() { return fetchApi('/budgets/template', {}, true); }
export async function uploadBudget(file) { const formData = new FormData(); formData.append('budgetFile', file); return fetchApi('/budgets/upload', { method: 'POST', body: formData }, true); }

// PLANNED INCOME
export async function getActivePlannedIncome() { return fetchApi('/planned-income'); }
export async function createPlannedIncome(incomeData) { return fetchApi('/planned-income', { method: 'POST', body: JSON.stringify(incomeData) }); }
export async function updatePlannedIncome(id, incomeData) { return fetchApi(`/planned-income/${id}`, { method: 'PUT', body: JSON.stringify(incomeData) }); }
export async function deactivatePlannedIncome(id) { return fetchApi(`/planned-income/${id}`, { method: 'DELETE', }); }

// SAVINGS
export async function getAllSavingsAccounts() { return fetchApi('/savings/accounts'); }
export async function createSavingsAccount(accountData) { return fetchApi('/savings/accounts', { method: 'POST', body: JSON.stringify(accountData) }); }
export async function updateSavingsAccount(id, accountData) { return fetchApi(`/savings/accounts/${id}`, { method: 'PUT', body: JSON.stringify(accountData) }); }
export async function deleteSavingsAccount(id) { return fetchApi(`/savings/accounts/${id}`, { method: 'DELETE' }); }
export async function createSavingsGoal(goalData) { return fetchApi('/savings/goals', { method: 'POST', body: JSON.stringify(goalData) }); }
export async function updateSavingsGoal(id, goalData) { return fetchApi(`/savings/goals/${id}`, { method: 'PUT', body: JSON.stringify(goalData) }); }
export async function deleteSavingsGoal(id) { return fetchApi(`/savings/goals/${id}`, { method: 'DELETE' }); }
export async function withdrawFromSavingsGoal(id, withdrawalData) { return fetchApi(`/savings/goals/${id}/withdraw`, { method: 'POST', body: JSON.stringify(withdrawalData) }); }

// BACKUP
export async function downloadBackup() {
    const blob = await fetchApi('/backup/create', {}, true);
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `budget_backup_${new Date().toISOString().split('T')[0]}.db`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    window.URL.revokeObjectURL(url);
}

export async function restoreBackup(file) {
    const formData = new FormData();
    formData.append('backupFile', file);
    return fetchApi('/backup/restore', { method: 'POST', body: formData }, true);
}
